=begin
= resolv library
resolv.rb is a resolver library written in Ruby.
Since it is written in Ruby, it is thread-aware.
I.e. it can resolv many hostnames concurrently.

It is possible to lookup various resources of DNS using DNS module directly.

== example
  p Resolv.getaddress("www.ruby-lang.org")
  p Resolv.getname("210.251.121.214")

  Resolv::DNS.open {|dns|
    p dns.getresources("www.ruby-lang.org", Resolv::DNS::Resource::IN::A).collect {|r| r.address}
    p dns.getresources("ruby-lang.org", Resolv::DNS::Resource::IN::MX).collect {|r| [r.exchange.to_s, r.preference]}
  }

== Resolv class

=== class methods
--- Resolv.getaddress(name)
--- Resolv.getaddresses(name)
--- Resolv.each_address(name) {|address| ...}
    They lookups IP addresses of ((|name|)) which represents a hostname
    as a string by default resolver.

    getaddress returns first entry of lookupped addresses.
    getaddresses returns lookupped addresses as an array.
    each_address iterates over lookupped addresses.

--- Resolv.getname(address)
--- Resolv.getnames(address)
--- Resolv.each_name(address) {|name| ...}
    lookups hostnames of ((|address|)) which represents IP address as a string.

    getname returns first entry of lookupped names.
    getnames returns lookupped names as an array.
    each_names iterates over lookupped names.

== Resolv::Hosts class
hostname resolver using /etc/hosts format.

=== class methods
--- Resolv::Hosts.new(hosts='/etc/hosts')

=== methods
--- Resolv::Hosts#getaddress(name)
--- Resolv::Hosts#getaddresses(name)
--- Resolv::Hosts#each_address(name) {|address| ...}
    address lookup methods.

--- Resolv::Hosts#getname(address)
--- Resolv::Hosts#getnames(address)
--- Resolv::Hosts#each_name(address) {|name| ...}
    hostnames lookup methods.

== Resolv::DNS class
DNS stub resolver.

=== class methods
--- Resolv::DNS.new(config_info=nil)

    ((|config_info|)) should be nil, a string or a hash.
    If nil is given, /etc/resolv.conf and platform specific information is used.
    If a string is given, it should be a filename which format is same as /etc/resolv.conf.
    If a hash is given, it may contains information for nameserver, search and ndots as follows.

      Resolv::DNS.new({:nameserver=>["210.251.121.21"], :search=>["ruby-lang.org"], :ndots=>1})

--- Resolv::DNS.open(config_info=nil)
--- Resolv::DNS.open(config_info=nil) {|dns| ...}

=== methods
--- Resolv::DNS#close

--- Resolv::DNS#getaddress(name)
--- Resolv::DNS#getaddresses(name)
--- Resolv::DNS#each_address(name) {|address| ...}
    address lookup methods.

    ((|name|)) must be a instance of Resolv::DNS::Name or String.  Lookupped
    address is represented as an instance of Resolv::IPv4 or Resolv::IPv6.

--- Resolv::DNS#getname(address)
--- Resolv::DNS#getnames(address)
--- Resolv::DNS#each_name(address) {|name| ...}
    hostnames lookup methods.

    ((|address|)) must be a instance of Resolv::IPv4, Resolv::IPv6 or String.
    Lookupped name is represented as an instance of Resolv::DNS::Name.

--- Resolv::DNS#getresource(name, typeclass)
--- Resolv::DNS#getresources(name, typeclass)
--- Resolv::DNS#each_resource(name, typeclass) {|resource| ...}
    They lookup DNS resources of ((|name|)).
    ((|name|)) must be a instance of Resolv::Name or String.

    ((|typeclass|)) should be one of follows:
    * Resolv::DNS::Resource::IN::ANY
    * Resolv::DNS::Resource::IN::NS
    * Resolv::DNS::Resource::IN::CNAME
    * Resolv::DNS::Resource::IN::SOA
    * Resolv::DNS::Resource::IN::HINFO
    * Resolv::DNS::Resource::IN::MINFO
    * Resolv::DNS::Resource::IN::MX
    * Resolv::DNS::Resource::IN::TXT
    * Resolv::DNS::Resource::IN::ANY
    * Resolv::DNS::Resource::IN::A
    * Resolv::DNS::Resource::IN::WKS
    * Resolv::DNS::Resource::IN::PTR
    * Resolv::DNS::Resource::IN::AAAA

    Lookupped resource is represented as an instance of (a subclass of)
    Resolv::DNS::Resource. 
    (Resolv::DNS::Resource::IN::A, etc.)

== Resolv::DNS::Resource::IN::NS class
--- name
== Resolv::DNS::Resource::IN::CNAME class
--- name
== Resolv::DNS::Resource::IN::SOA class
--- mname
--- rname
--- serial
--- refresh
--- retry
--- expire
--- minimum
== Resolv::DNS::Resource::IN::HINFO class
--- cpu
--- os
== Resolv::DNS::Resource::IN::MINFO class
--- rmailbx
--- emailbx
== Resolv::DNS::Resource::IN::MX class
--- preference
--- exchange
== Resolv::DNS::Resource::IN::TXT class
--- data
== Resolv::DNS::Resource::IN::A class
--- address
== Resolv::DNS::Resource::IN::WKS class
--- address
--- protocol
--- bitmap
== Resolv::DNS::Resource::IN::PTR class
--- name
== Resolv::DNS::Resource::IN::AAAA class
--- address

== Resolv::DNS::Name class

=== class methods
--- Resolv::DNS::Name.create(name)

=== methods
--- Resolv::DNS::Name#to_s

== Resolv::DNS::Resource class

== Resolv::IPv4 class
=== class methods
--- Resolv::IPv4.create(address)

=== methods
--- Resolv::IPv4#to_s
--- Resolv::IPv4#to_name

=== constants
--- Resolv::IPv4::Regex
    regular expression for IPv4 address.

== Resolv::IPv6 class
=== class methods
--- Resolv::IPv6.create(address)

=== methods
--- Resolv::IPv6#to_s
--- Resolv::IPv6#to_name

=== constants
--- Resolv::IPv6::Regex
    regular expression for IPv6 address.

== Bugs
* NIS is not supported.
* /etc/nsswitch.conf is not supported.
* IPv6 is not supported.

=end

|>METHOD:require<| 'socket'
|>METHOD:require<| 'fcntl'
|>METHOD:require<| 'timeout'
|>METHOD:require<| 'thread'

class Resolv
  def self.|>METHOD:getaddress<|(|>PARAMETER:name<|)
    DefaultResolver.getaddress(|>PARAMETER:name<|)
  end

  def self.|>METHOD:getaddresses<|(|>PARAMETER:name<|)
    DefaultResolver.getaddresses(|>PARAMETER:name<|)
  end

  def self.|>METHOD:each_address<|(|>PARAMETER:name<|, |>PARAMETER:&block<|)
    DefaultResolver.each_address(|>PARAMETER:name<|, &|>PARAMETER:block<|)
  end

  def self.|>METHOD:getname<|(|>PARAMETER:address<|)
    DefaultResolver.getname(|>PARAMETER:address<|)
  end

  def self.|>METHOD:getnames<|(|>PARAMETER:address<|)
    DefaultResolver.getnames(|>PARAMETER:address<|)
  end

  def self.|>METHOD:each_name<|(|>PARAMETER:address<|, |>PARAMETER:&proc<|)
    DefaultResolver.each_name(|>PARAMETER:address<|, &|>PARAMETER:proc<|)
  end

  def |>METHOD:initialize<|(|>PARAMETER:resolvers<|=[Hosts.new, DNS.new])
    @resolvers = |>PARAMETER:resolvers<|
  end

  def |>METHOD:getaddress<|(|>PARAMETER:name<|)
    |>METHOD:each_address<|(|>PARAMETER:name<|) {|address| return address}
    |>METHOD:raise<| ResolvError.new("no address for #{|>PARAMETER:name<|}")
  end

  def |>METHOD:getaddresses<|(|>PARAMETER:name<|)
    ret = []
    |>METHOD:each_address<|(|>PARAMETER:name<|) {|address| ret << address}
    return ret
  end

  def |>METHOD:each_address<|(|>PARAMETER:name<|)
    if AddressRegex =~ |>PARAMETER:name<|
      yield |>PARAMETER:name<|
      return
    end
    yielded = false
    @resolvers.each {|r|
      r.each_address(|>PARAMETER:name<|) {|address|
        yield address.to_s
        yielded = true
      }
      return if yielded
    }
  end

  def |>METHOD:getname<|(|>PARAMETER:address<|)
    |>METHOD:each_name<|(|>PARAMETER:address<|) {|name| return name}
    |>METHOD:raise<| ResolvError.new("no name for #{|>PARAMETER:address<|}")
  end

  def |>METHOD:getnames<|(|>PARAMETER:address<|)
    ret = []
    |>METHOD:each_name<|(|>PARAMETER:address<|) {|name| ret << name}
    return ret
  end

  def |>METHOD:each_name<|(|>PARAMETER:address<|)
    yielded = false
    @resolvers.each {|r|
      r.each_name(|>PARAMETER:address<|) {|name|
        yield name.to_s
        yielded = true
      }
      return if yielded
    }
  end

  class ResolvError < StandardError
  end

  class ResolvTimeout < TimeoutError
  end

  class Hosts
    if /mswin32|cygwin|mingw|bccwin/ =~ RUBY_PLATFORM
      |>METHOD:require<| 'win32/resolv'
      DefaultFileName = Win32::Resolv.get_hosts_path
    else
      DefaultFileName = '/etc/hosts'
    end

    def |>METHOD:initialize<|(|>PARAMETER:filename<| = DefaultFileName)
      @filename = |>PARAMETER:filename<|
      @mutex = Mutex.new
      @initialized = nil
    end

    def |>METHOD:lazy_initialize<|
      @mutex.synchronize {
        unless @initialized
          @name2addr = {}
          @addr2name = {}
          |>METHOD:open<|(@filename) {|f|
            f.each {|line|
              line.sub!(/#.*/, '')
              addr, hostname, *aliases = line.split(/\s+/)
              next unless addr
              addr.untaint
              hostname.untaint
              @addr2name[addr] = [] unless @addr2name.include? addr
              @addr2name[addr] << hostname
              @addr2name[addr] += aliases
              @name2addr[hostname] = [] unless @name2addr.include? hostname
              @name2addr[hostname] << addr
              aliases.each {|n|
                n.untaint
                @name2addr[n] = [] unless @name2addr.include? n
                @name2addr[n] << addr
              }
            }
          }
          @name2addr.each {||>UNUSED:name<|, arr| arr.reverse!}
          @initialized = true
        end
      }
      self
    end

    def |>METHOD:getaddress<|(|>PARAMETER:name<|)
      |>METHOD:each_address<|(|>PARAMETER:name<|) {|address| return address}
      |>METHOD:raise<| ResolvError.new("#{@filename} has no name: #{|>PARAMETER:name<|}")
    end

    def |>METHOD:getaddresses<|(|>PARAMETER:name<|)
      ret = []
      |>METHOD:each_address<|(|>PARAMETER:name<|) {|address| ret << address}
      return ret
    end

    def |>METHOD:each_address<|(|>PARAMETER:name<|, |>PARAMETER:&proc<|)
      |>METHOD:lazy_initialize<|
      if @name2addr.include?(|>PARAMETER:name<|)
        @name2addr[|>PARAMETER:name<|].each(&|>PARAMETER:proc<|)
      end
    end

    def |>METHOD:getname<|(|>PARAMETER:address<|)
      |>METHOD:each_name<|(|>PARAMETER:address<|) {|name| return name}
      |>METHOD:raise<| ResolvError.new("#{@filename} has no address: #{|>PARAMETER:address<|}")
    end

    def |>METHOD:getnames<|(|>PARAMETER:address<|)
      ret = []
      |>METHOD:each_name<|(|>PARAMETER:address<|) {|name| ret << name}
      return ret
    end

    def |>METHOD:each_name<|(|>PARAMETER:address<|, |>PARAMETER:&proc<|)
      |>METHOD:lazy_initialize<|
      if @addr2name.include?(|>PARAMETER:address<|)
        @addr2name[|>PARAMETER:address<|].each(&|>PARAMETER:proc<|)
      end
    end
  end

  class DNS
    # STD0013 (RFC 1035, etc.)
    # ftp://ftp.isi.edu/in-notes/iana/assignments/dns-parameters

    Port = 53
    UDPSize = 512

    DNSThreadGroup = ThreadGroup.new

    def self.|>METHOD:open<|(|>PARAMETER:*args<|)
      dns = |>METHOD:new<|(*|>PARAMETER:args<|)
      return dns unless |>METHOD:block_given?<|
      begin
        yield dns
      ensure
        dns.close
      end
    end

    def |>METHOD:initialize<|(|>PARAMETER:config_info<|=nil)
      @mutex = Mutex.new
      @config = Config.new(|>PARAMETER:config_info<|)
      @initialized = nil
    end

    def |>METHOD:lazy_initialize<|
      @mutex.synchronize {
        unless @initialized
          @config.lazy_initialize

          if nameserver = @config.single?
            @requester = Requester::ConnectedUDP.new(nameserver)
          else
            @requester = Requester::UnconnectedUDP.new
          end

          @initialized = true
        end
      }
      self
    end

    def |>METHOD:close<|
      @mutex.synchronize {
        if @initialized
          @requester.close if @requester
          @requester = nil
          @initialized = false
        end
      }
    end

    def |>METHOD:getaddress<|(|>PARAMETER:name<|)
      |>METHOD:each_address<|(|>PARAMETER:name<|) {|address| return address}
      |>METHOD:raise<| ResolvError.new("DNS result has no information for #{|>PARAMETER:name<|}")
    end

    def |>METHOD:getaddresses<|(|>PARAMETER:name<|)
      ret = []
      |>METHOD:each_address<|(|>PARAMETER:name<|) {|address| ret << address}
      return ret
    end

    def |>METHOD:each_address<|(|>PARAMETER:name<|)
      |>METHOD:each_resource<|(|>PARAMETER:name<|, Resource::IN::A) {|resource| yield resource.address}
    end

    def |>METHOD:getname<|(|>PARAMETER:address<|)
      |>METHOD:each_name<|(|>PARAMETER:address<|) {|name| return name}
      |>METHOD:raise<| ResolvError.new("DNS result has no information for #{|>PARAMETER:address<|}")
    end

    def |>METHOD:getnames<|(|>PARAMETER:address<|)
      ret = []
      |>METHOD:each_name<|(|>PARAMETER:address<|) {|name| ret << name}
      return ret
    end

    def |>METHOD:each_name<|(|>PARAMETER:address<|)
      case |>PARAMETER:address<|
      when Name
        ptr = |>PARAMETER:address<|
      when IPv4::Regex
        ptr = IPv4.create(|>PARAMETER:address<|).to_name
      when IPv6::Regex
        ptr = IPv6.create(|>PARAMETER:address<|).to_name
      else
        |>METHOD:raise<| ResolvError.new("cannot interpret as address: #{|>PARAMETER:address<|}")
      end
      |>METHOD:each_resource<|(ptr, Resource::IN::PTR) {|resource| yield resource.name}
    end

    def |>METHOD:getresource<|(|>PARAMETER:name<|, |>PARAMETER:typeclass<|)
      |>METHOD:each_resource<|(|>PARAMETER:name<|, |>PARAMETER:typeclass<|) {|resource| return resource}
      |>METHOD:raise<| ResolvError.new("DNS result has no information for #{|>PARAMETER:name<|}")
    end

    def |>METHOD:getresources<|(|>PARAMETER:name<|, |>PARAMETER:typeclass<|)
      ret = []
      |>METHOD:each_resource<|(|>PARAMETER:name<|, |>PARAMETER:typeclass<|) {|resource| ret << resource}
      return ret
    end

    def |>METHOD:each_resource<|(|>PARAMETER:name<|, |>PARAMETER:typeclass<|, |>PARAMETER:&proc<|)
      |>METHOD:lazy_initialize<|
      q = Queue.new
      senders = {}
      begin
        @config.resolv(|>PARAMETER:name<|) {|candidate, tout, nameserver|
          msg = Message.new
          msg.rd = 1
          msg.add_question(candidate, |>PARAMETER:typeclass<|)
          unless sender = senders[[candidate, nameserver]]
            sender = senders[[candidate, nameserver]] =
              @requester.sender(msg, candidate, q, nameserver)
          end
          sender.send
          reply = reply_name = nil
          |>METHOD:timeout<|(tout, ResolvTimeout) { reply, reply_name = q.pop }
          case reply.rcode
          when RCode::NoError
            |>METHOD:extract_resources<|(reply, reply_name, |>PARAMETER:typeclass<|, &|>PARAMETER:proc<|)
            return
          when RCode::NXDomain
            |>METHOD:raise<| Config::NXDomain.new(reply_name.to_s)
          else
            |>METHOD:raise<| Config::OtherResolvError.new(reply_name.to_s)
          end
        }
      ensure
        @requester.delete(q)
      end
    end

    def |>METHOD:extract_resources<|(|>PARAMETER:msg<|, |>PARAMETER:name<|, |>PARAMETER:typeclass<|)
      if |>PARAMETER:typeclass<| < Resource::ANY
        n0 = Name.create(|>PARAMETER:name<|)
        |>PARAMETER:msg<|.each_answer {|n, |>UNUSED:ttl<|, data|
          yield data if n0 == n
        }
      end
      yielded = false
      n0 = Name.create(|>PARAMETER:name<|)
      |>PARAMETER:msg<|.each_answer {|n, |>UNUSED:ttl<|, data|
        if n0 == n
          case data
          when |>PARAMETER:typeclass<|
            yield data
            yielded = true
          when Resource::CNAME
            n0 = data.name
          end
        end
      }
      return if yielded
      |>PARAMETER:msg<|.each_answer {|n, |>UNUSED:ttl<|, data|
        if n0 == n
          case data
          when |>PARAMETER:typeclass<|
            yield data
          end
        end
      }
    end

    class Requester
      def |>METHOD:initialize<|
        @senders = {}
      end

      def |>METHOD:close<|
        thread, sock, @thread, @sock = @thread, @sock
        begin
          if thread
            thread.kill
            thread.join
          end
        ensure
          sock.close if sock
        end
      end

      def |>METHOD:delete<|(|>PARAMETER:arg<|)
        case |>PARAMETER:arg<|
        when Sender
          @senders.delete_if {||>UNUSED:k<|, s| s == |>PARAMETER:arg<| }
        when Queue
          @senders.delete_if {||>UNUSED:k<|, s| s.queue == |>PARAMETER:arg<| }
        else
          |>METHOD:raise<| ArgumentError.new("neither Sender or Queue: #{|>PARAMETER:arg<|}")
        end
      end

      class Sender
        def |>METHOD:initialize<|(|>PARAMETER:msg<|, |>PARAMETER:data<|, |>PARAMETER:sock<|, |>PARAMETER:queue<|)
          @msg = |>PARAMETER:msg<|
          @data = |>PARAMETER:data<|
          @sock = |>PARAMETER:sock<|
          @queue = |>PARAMETER:queue<|
        end
        |>METHOD:attr_reader<| :queue

        def |>METHOD:recv<|(|>PARAMETER:msg<|)
          @queue.push([|>PARAMETER:msg<|, @data])
        end
      end

      class UnconnectedUDP < Requester
        def |>METHOD:initialize<|
          super()
          @sock = UDPSocket.new
          @sock.fcntl(Fcntl::F_SETFD, 1) if defined? Fcntl::F_SETFD
          @id = {}
          @id.default = -1
          @thread = Thread.new {
            DNSThreadGroup.add Thread.current
            |>METHOD:loop<| {
              reply, from = @sock.recvfrom(UDPSize)
              msg = begin
                Message.decode(reply)
              rescue DecodeError
                STDERR.print("DNS message decoding error: #{reply.inspect}\n")
                next
              end
              if s = @senders[[[from[3],from[1]],msg.id]]
                s.recv msg
              else
                #STDERR.print("non-handled DNS message: #{msg.inspect} from #{from.inspect}\n")
              end
            }
          }
        end

        def |>METHOD:sender<|(|>PARAMETER:msg<|, |>PARAMETER:data<|, |>PARAMETER:queue<|, |>PARAMETER:host<|, |>PARAMETER:port<|=Port)
          service = [|>PARAMETER:host<|, |>PARAMETER:port<|]
          id = Thread.exclusive {
            @id[service] = (@id[service] + 1) & 0xffff
          }
          request = |>PARAMETER:msg<|.encode
          request[0,2] = [id].pack('n')
          return @senders[[service, id]] =
            Sender.new(request, |>PARAMETER:data<|, @sock, |>PARAMETER:host<|, |>PARAMETER:port<|, |>PARAMETER:queue<|)
        end

        class Sender < Requester::Sender
          def |>METHOD:initialize<|(|>PARAMETER:msg<|, |>PARAMETER:data<|, |>PARAMETER:sock<|, |>PARAMETER:host<|, |>PARAMETER:port<|, |>PARAMETER:queue<|)
            super(|>PARAMETER:msg<|, |>PARAMETER:data<|, |>PARAMETER:sock<|, |>PARAMETER:queue<|)
            @host = |>PARAMETER:host<|
            @port = |>PARAMETER:port<|
          end

          def |>METHOD:send<|
            @sock.send(@msg, 0, @host, @port)
          end
        end
      end

      class ConnectedUDP < Requester
        def |>METHOD:initialize<|(|>PARAMETER:host<|, |>PARAMETER:port<|=Port)
          super()
          @host = |>PARAMETER:host<|
          @port = |>PARAMETER:port<|
          @sock = UDPSocket.new(|>PARAMETER:host<|.index(':') ? Socket::AF_INET6 : Socket::AF_INET)
          @sock.connect(|>PARAMETER:host<|, |>PARAMETER:port<|)
          @sock.fcntl(Fcntl::F_SETFD, 1) if defined? Fcntl::F_SETFD
          @id = -1
          @thread = Thread.new {
            DNSThreadGroup.add Thread.current
            |>METHOD:loop<| {
              reply = @sock.recv(UDPSize)
              msg = begin
                Message.decode(reply)
              rescue DecodeError
                STDERR.print("DNS message decoding error: #{reply.inspect}")
                next
              end
              if s = @senders[msg.id]
                s.recv msg
              else
                #STDERR.print("non-handled DNS message: #{msg.inspect}")
              end
            }
          }
        end

        def |>METHOD:sender<|(|>PARAMETER:msg<|, |>PARAMETER:data<|, |>PARAMETER:queue<|, |>PARAMETER:host<|=@host, |>PARAMETER:port<|=@port)
          unless |>PARAMETER:host<| == @host && |>PARAMETER:port<| == @port
            |>METHOD:raise<| RequestError.new("host/port don't match: #{|>PARAMETER:host<|}:#{|>PARAMETER:port<|}")
          end
          id = Thread.exclusive { @id = (@id + 1) & 0xffff }
          request = |>PARAMETER:msg<|.encode
          request[0,2] = [id].pack('n')
          return @senders[id] = Sender.new(request, |>PARAMETER:data<|, @sock, |>PARAMETER:queue<|)
        end

        class Sender < Requester::Sender
          def |>METHOD:send<|
            @sock.send(@msg, 0)
          end
        end
      end

      class TCP < Requester
        def |>METHOD:initialize<|(|>PARAMETER:host<|, |>PARAMETER:port<|=Port)
          super()
          @host = |>PARAMETER:host<|
          @port = |>PARAMETER:port<|
          @sock = TCPSocket.new
          @sock.connect(|>PARAMETER:host<|, |>PARAMETER:port<|)
          @sock.fcntl(Fcntl::F_SETFD, 1) if defined? Fcntl::F_SETFD
          @id = -1
          @senders = {}
          @thread = Thread.new {
            DNSThreadGroup.add Thread.current
            |>METHOD:loop<| {
              len = @sock.read(2).unpack('n')
              reply = @sock.read(len)
              msg = begin
                Message.decode(reply)
              rescue DecodeError
                STDERR.print("DNS message decoding error: #{reply.inspect}")
                next
              end
              if s = @senders[msg.id]
                s.push msg
              else
                #STDERR.print("non-handled DNS message: #{msg.inspect}")
              end
            }
          }
        end

        def |>METHOD:sender<|(|>PARAMETER:msg<|, |>PARAMETER:data<|, |>PARAMETER:queue<|, |>PARAMETER:host<|=@host, |>PARAMETER:port<|=@port)
          unless |>PARAMETER:host<| == @host && |>PARAMETER:port<| == @port
            |>METHOD:raise<| RequestError.new("host/port don't match: #{|>PARAMETER:host<|}:#{|>PARAMETER:port<|}")
          end
          id = Thread.exclusive { @id = (@id + 1) & 0xffff }
          request = |>PARAMETER:msg<|.encode
          request[0,2] = [request.length, id].pack('nn')
          return @senders[id] = Sender.new(request, |>PARAMETER:data<|, @sock, |>PARAMETER:queue<|)
        end

        class Sender < Requester::Sender
          def |>METHOD:send<|
            @sock.print(@msg)
            @sock.flush
          end
        end
      end

      class RequestError < StandardError
      end
    end

    class Config
      def |>METHOD:initialize<|(|>PARAMETER:config_info<|=nil)
        @mutex = Mutex.new
        @config_info = |>PARAMETER:config_info<|
        @initialized = nil
      end

      def Config.|>METHOD:parse_resolv_conf<|(|>PARAMETER:filename<|)
        nameserver = []
        search = nil
        ndots = 1
        |>METHOD:open<|(|>PARAMETER:filename<|) {|f|
          f.each {|line|
            line.sub!(/[#;].*/, '')
            keyword, *args = line.split(/\s+/)
            args.each { |arg|
              arg.untaint
            }
            next unless keyword
            case keyword
            when 'nameserver'
              nameserver += args
            when 'domain'
              next if args.empty?
              search = [args[0]]
            when 'search'
              next if args.empty?
              search = args
            when 'options'
              args.each {|arg|
                case arg
                when /\Andots:(\d+)\z/
                  ndots = $1.to_i
                end
              }
            end
          }
        }
        return { :nameserver => nameserver, :search => search, :ndots => ndots }
      end

      def Config.|>METHOD:default_config_hash<|(|>PARAMETER:filename<|="/etc/resolv.conf")
        if File.exist? |>PARAMETER:filename<|
          config_hash = Config.parse_resolv_conf(|>PARAMETER:filename<|)
        else
          if /mswin32|cygwin|mingw|bccwin/ =~ RUBY_PLATFORM
            search, nameserver = Win32::Resolv.get_resolv_info
            config_hash = {}
            config_hash[:nameserver] = nameserver if nameserver
            config_hash[:search] = [search].flatten if search
          end
        end
        config_hash
      end

      def |>METHOD:lazy_initialize<|
        @mutex.synchronize {
          unless @initialized
            @nameserver = []
            @search = nil
            @ndots = 1
            case @config_info
            when nil
              config_hash = Config.default_config_hash
            when String
              config_hash = Config.parse_resolv_conf(@config_info)
            when Hash
              config_hash = @config_info.dup
              if String === config_hash[:nameserver]
                config_hash[:nameserver] = [config_hash[:nameserver]]
              end
              if String === config_hash[:search]
                config_hash[:search] = [config_hash[:search]]
              end
            else
              |>METHOD:raise<| ArgumentError.new("invalid resolv configuration: #{@config_info.inspect}")
            end
            @nameserver = config_hash[:nameserver] if config_hash.include? :nameserver
            @search = config_hash[:search] if config_hash.include? :search
            @ndots = config_hash[:ndots] if config_hash.include? :ndots

            @nameserver = ['0.0.0.0'] if @nameserver.empty?
            if @search
              @search = @search.map {|arg| Label.split(arg) }
            else
              hostname = Socket.gethostname
              if /\./ =~ hostname
                @search = [Label.split($')]
              else
                @search = [[]]
              end
            end

            if !@nameserver.kind_of?(Array) ||
                !@nameserver.all? {|ns| String === ns }
              |>METHOD:raise<| ArgumentError.new("invalid nameserver config: #{@nameserver.inspect}")
            end

            if !@search.kind_of?(Array) ||
                !@search.all? {|ls| ls.all? {|l| Label::Str === l } }
              |>METHOD:raise<| ArgumentError.new("invalid search config: #{@search.inspect}")
            end

            if !@ndots.kind_of?(Integer)
              |>METHOD:raise<| ArgumentError.new("invalid ndots config: #{@ndots.inspect}")
            end

            @initialized = true
          end
        }
        self
      end

      def |>METHOD:single?<|
        |>METHOD:lazy_initialize<|
        if @nameserver.length == 1
          return @nameserver[0]
        else
          return nil
        end
      end

      def |>METHOD:generate_candidates<|(|>PARAMETER:name<|)
        candidates = nil
        |>PARAMETER:name<| = Name.create(|>PARAMETER:name<|)
        if |>PARAMETER:name<|.absolute?
          candidates = [|>PARAMETER:name<|]
        else
          if @ndots <= |>PARAMETER:name<|.length - 1
            candidates = [Name.new(|>PARAMETER:name<|.to_a)]
          else
            candidates = []
          end
          candidates.concat(@search.map {|domain| Name.new(|>PARAMETER:name<|.to_a + domain)})
        end
        return candidates
      end

      InitialTimeout = 5

      def |>METHOD:generate_timeouts<|
        ts = [InitialTimeout]
        ts << ts[-1] * 2 / @nameserver.length
        ts << ts[-1] * 2
        ts << ts[-1] * 2
        return ts
      end

      def |>METHOD:resolv<|(|>PARAMETER:name<|)
        candidates = |>METHOD:generate_candidates<|(|>PARAMETER:name<|)
        timeouts = |>METHOD:generate_timeouts<|
        begin
          candidates.each {|candidate|
            begin
              timeouts.each {|tout|
                @nameserver.each {|nameserver|
                  begin
                    yield candidate, tout, nameserver
                  rescue ResolvTimeout
                  end
                }
              }
              |>METHOD:raise<| ResolvError.new("DNS resolv timeout: #{|>PARAMETER:name<|}")
            rescue NXDomain
            end
          }
        rescue ResolvError
        end
      end

      class NXDomain < ResolvError
      end

      class OtherResolvError < ResolvError
      end
    end

    module OpCode
      Query = 0
      IQuery = 1
      Status = 2
      Notify = 4
      Update = 5
    end

    module RCode
      NoError = 0
      FormErr = 1
      ServFail = 2
      NXDomain = 3
      NotImp = 4
      Refused = 5
      YXDomain = 6
      YXRRSet = 7
      NXRRSet = 8
      NotAuth = 9
      NotZone = 10
      BADVERS = 16
      BADSIG = 16
      BADKEY = 17
      BADTIME = 18
      BADMODE = 19
      BADNAME = 20
      BADALG = 21
    end

    class DecodeError < StandardError
    end

    class EncodeError < StandardError
    end

    module Label
      def self.|>METHOD:split<|(|>PARAMETER:arg<|)
        labels = []
        |>PARAMETER:arg<|.scan(/[^\.]+/) {labels << Str.new($&)}
        return labels
      end

      class Str
        def |>METHOD:initialize<|(|>PARAMETER:string<|)
          @string = |>PARAMETER:string<|
          @downcase = |>PARAMETER:string<|.downcase
        end
        |>METHOD:attr_reader<| :string, :downcase

        def |>METHOD:to_s<|
          return @string
        end

        def |>METHOD:inspect<|
          return "#<#{self.class} #{self.to_s}>"
        end

        def |>METHOD:==<|(|>PARAMETER:other<|)
          return @downcase == |>PARAMETER:other<|.downcase
        end

        def |>METHOD:eql?<|(|>PARAMETER:other<|)
          return self == |>PARAMETER:other<|
        end

        def |>METHOD:hash<|
          return @downcase.hash
        end
      end
    end

    class Name
      def self.|>METHOD:create<|(|>PARAMETER:arg<|)
        case |>PARAMETER:arg<|
        when Name
          return |>PARAMETER:arg<|
        when String
          return Name.new(Label.split(|>PARAMETER:arg<|), /\.\z/ =~ |>PARAMETER:arg<| ? true : false)
        else
          |>METHOD:raise<| ArgumentError.new("cannot interpret as DNS name: #{|>PARAMETER:arg<|.inspect}")
        end
      end

      def |>METHOD:initialize<|(|>PARAMETER:labels<|, |>PARAMETER:absolute<|=true)
        @labels = |>PARAMETER:labels<|
        @absolute = |>PARAMETER:absolute<|
      end

      def |>METHOD:inspect<|
        "#<#{self.class}: #{self.to_s}#{@absolute ? '.' : ''}>"
      end

      def |>METHOD:absolute?<|
        return @absolute
      end

      def |>METHOD:==<|(|>PARAMETER:other<|)
        return false unless Name === |>PARAMETER:other<|
        return @labels == |>PARAMETER:other<|.to_a && @absolute == |>PARAMETER:other<|.absolute?
      end
      alias eql? ==

      # tests subdomain-of relation.
      #
      #   domain = Resolv::DNS::Name.create("y.z")
      #   p Resolv::DNS::Name.create("w.x.y.z").subdomain_of?(domain) #=> true
      #   p Resolv::DNS::Name.create("x.y.z").subdomain_of?(domain) #=> true
      #   p Resolv::DNS::Name.create("y.z").subdomain_of?(domain) #=> false
      #   p Resolv::DNS::Name.create("z").subdomain_of?(domain) #=> false
      #   p Resolv::DNS::Name.create("x.y.z.").subdomain_of?(domain) #=> false
      #   p Resolv::DNS::Name.create("w.z").subdomain_of?(domain) #=> false
      #
      def |>METHOD:subdomain_of?<|(|>PARAMETER:other<|)
        |>METHOD:raise<| ArgumentError, "not a domain name: #{|>PARAMETER:other<|.inspect}" unless Name === |>PARAMETER:other<|
        return false if @absolute != |>PARAMETER:other<|.absolute?
        other_len = |>PARAMETER:other<|.length
        return false if @labels.length <= other_len
        return @labels[-other_len, other_len] == |>PARAMETER:other<|.to_a
      end

      def |>METHOD:hash<|
        return @labels.hash ^ @absolute.hash
      end

      def |>METHOD:to_a<|
        return @labels
      end

      def |>METHOD:length<|
        return @labels.length
      end

      def [](|>PARAMETER:i<|)
        return @labels[|>PARAMETER:i<|]
      end

      # returns the domain name as a string.
      #
      # The domain name doesn't have a trailing dot even if the name object is
      # absolute.
      #
      #   p Resolv::DNS::Name.create("x.y.z.").to_s #=> "x.y.z"
      #   p Resolv::DNS::Name.create("x.y.z").to_s #=> "x.y.z"
      #
      def |>METHOD:to_s<|
        return @labels.join('.')
      end
    end

    class Message
      @@identifier = -1

      def |>METHOD:initialize<|(|>PARAMETER:id<| = (@@identifier += 1) & 0xffff)
        @id = |>PARAMETER:id<|
        @qr = 0
        @opcode = 0
        @aa = 0
        @tc = 0
        @rd = 0 # recursion desired
        @ra = 0 # recursion available
        @rcode = 0
        @question = []
        @answer = []
        @authority = []
        @additional = []
      end

      |>METHOD:attr_accessor<| :id, :qr, :opcode, :aa, :tc, :rd, :ra, :rcode
      |>METHOD:attr_reader<| :question, :answer, :authority, :additional

      def |>METHOD:==<|(|>PARAMETER:other<|)
        return @id == |>PARAMETER:other<|.id &&
          @qr == |>PARAMETER:other<|.qr &&
          @opcode == |>PARAMETER:other<|.opcode &&
          @aa == |>PARAMETER:other<|.aa &&
          @tc == |>PARAMETER:other<|.tc &&
          @rd == |>PARAMETER:other<|.rd &&
          @ra == |>PARAMETER:other<|.ra &&
          @rcode == |>PARAMETER:other<|.rcode &&
          @question == |>PARAMETER:other<|.question &&
          @answer == |>PARAMETER:other<|.answer &&
          @authority == |>PARAMETER:other<|.authority &&
          @additional == |>PARAMETER:other<|.additional
      end

      def |>METHOD:add_question<|(|>PARAMETER:name<|, |>PARAMETER:typeclass<|)
        @question << [Name.create(|>PARAMETER:name<|), |>PARAMETER:typeclass<|]
      end

      def |>METHOD:each_question<|
        @question.each {|name, typeclass|
          yield name, typeclass
        }
      end

      def |>METHOD:add_answer<|(|>PARAMETER:name<|, |>PARAMETER:ttl<|, |>PARAMETER:data<|)
        @answer << [Name.create(|>PARAMETER:name<|), |>PARAMETER:ttl<|, |>PARAMETER:data<|]
      end

      def |>METHOD:each_answer<|
        @answer.each {|name, ttl, data|
          yield name, ttl, data
        }
      end

      def |>METHOD:add_authority<|(|>PARAMETER:name<|, |>PARAMETER:ttl<|, |>PARAMETER:data<|)
        @authority << [Name.create(|>PARAMETER:name<|), |>PARAMETER:ttl<|, |>PARAMETER:data<|]
      end

      def |>METHOD:each_authority<|
        @authority.each {|name, ttl, data|
          yield name, ttl, data
        }
      end

      def |>METHOD:add_additional<|(|>PARAMETER:name<|, |>PARAMETER:ttl<|, |>PARAMETER:data<|)
        @additional << [Name.create(|>PARAMETER:name<|), |>PARAMETER:ttl<|, |>PARAMETER:data<|]
      end

      def |>METHOD:each_additional<|
        @additional.each {|name, ttl, data|
          yield name, ttl, data
        }
      end

      def |>METHOD:each_resource<|
        |>METHOD:each_answer<| {|name, ttl, data| yield name, ttl, data}
        |>METHOD:each_authority<| {|name, ttl, data| yield name, ttl, data}
        |>METHOD:each_additional<| {|name, ttl, data| yield name, ttl, data}
      end

      def |>METHOD:encode<|
        return MessageEncoder.new {|msg|
          msg.put_pack('nnnnnn',
            @id,
            (@qr & 1) << 15 |
            (@opcode & 15) << 11 |
            (@aa & 1) << 10 |
            (@tc & 1) << 9 |
            (@rd & 1) << 8 |
            (@ra & 1) << 7 |
            (@rcode & 15),
            @question.length,
            @answer.length,
            @authority.length,
            @additional.length)
          @question.each {|q|
            name, typeclass = q
            msg.put_name(name)
            msg.put_pack('nn', typeclass::TypeValue, typeclass::ClassValue)
          }
          [@answer, @authority, @additional].each {|rr|
            rr.each {|r|
              name, ttl, data = r
              msg.put_name(name)
              msg.put_pack('nnN', data.class::TypeValue, data.class::ClassValue, ttl)
              msg.put_length16 {data.encode_rdata(msg)}
            }
          }
        }.to_s
      end

      class MessageEncoder
        def |>METHOD:initialize<|
          @data = ''
          @names = {}
          yield self
        end

        def |>METHOD:to_s<|
          return @data
        end

        def |>METHOD:put_bytes<|(|>PARAMETER:d<|)
          @data << |>PARAMETER:d<|
        end

        def |>METHOD:put_pack<|(|>PARAMETER:template<|, |>PARAMETER:*d<|)
          @data << |>PARAMETER:d<|.pack(|>PARAMETER:template<|)
        end

        def |>METHOD:put_length16<|
          length_index = @data.length
          @data << "\0\0"
          data_start = @data.length
          yield
          data_end = @data.length
          @data[length_index, 2] = [data_end - data_start].pack("n")
        end

        def |>METHOD:put_string<|(|>PARAMETER:d<|)
          self.put_pack("C", |>PARAMETER:d<|.length)
          @data << |>PARAMETER:d<|
        end

        def |>METHOD:put_string_list<|(|>PARAMETER:ds<|)
          |>PARAMETER:ds<|.each {|d|
            self.put_string(d)
          }
        end

        def |>METHOD:put_name<|(|>PARAMETER:d<|)
          |>METHOD:put_labels<|(|>PARAMETER:d<|.to_a)
        end

        def |>METHOD:put_labels<|(|>PARAMETER:d<|)
          |>PARAMETER:d<|.each_index {|i|
            domain = |>PARAMETER:d<|[i..-1]
            if idx = @names[domain]
              self.put_pack("n", 0xc000 | idx)
              return
            else
              @names[domain] = @data.length
              self.put_label(|>PARAMETER:d<|[i])
            end
          }
          @data << "\0"
        end

        def |>METHOD:put_label<|(|>PARAMETER:d<|)
          self.put_string(|>PARAMETER:d<|.string)
        end
      end

      def Message.|>METHOD:decode<|(|>PARAMETER:m<|)
        o = Message.new(0)
        MessageDecoder.new(|>PARAMETER:m<|) {|msg|
          id, flag, qdcount, ancount, nscount, arcount =
            msg.get_unpack('nnnnnn')
          o.id = id
          o.qr = (flag >> 15) & 1
          o.opcode = (flag >> 11) & 15
          o.aa = (flag >> 10) & 1
          o.tc = (flag >> 9) & 1
          o.rd = (flag >> 8) & 1
          o.ra = (flag >> 7) & 1
          o.rcode = flag & 15
          (1..qdcount).each {
            name, typeclass = msg.get_question
            o.add_question(name, typeclass)
          }
          (1..ancount).each {
            name, ttl, data = msg.get_rr
            o.add_answer(name, ttl, data)
          }
          (1..nscount).each {
            name, ttl, data = msg.get_rr
            o.add_authority(name, ttl, data)
          }
          (1..arcount).each {
            name, ttl, data = msg.get_rr
            o.add_additional(name, ttl, data)
          }
        }
        return o
      end

      class MessageDecoder
        def |>METHOD:initialize<|(|>PARAMETER:data<|)
          @data = |>PARAMETER:data<|
          @index = 0
          @limit = |>PARAMETER:data<|.length
          yield self
        end

        def |>METHOD:get_length16<|
          len, = self.get_unpack('n')
          save_limit = @limit
          @limit = @index + len
          d = yield(len)
          if @index < @limit
            |>METHOD:raise<| DecodeError.new("junk exists")
          elsif @limit < @index
            |>METHOD:raise<| DecodeError.new("limit exceeded")
          end
          @limit = save_limit
          return d
        end

        def |>METHOD:get_bytes<|(|>PARAMETER:len<| = @limit - @index)
          d = @data[@index, |>PARAMETER:len<|]
          @index += |>PARAMETER:len<|
          return d
        end

        def |>METHOD:get_unpack<|(|>PARAMETER:template<|)
          len = 0
          |>PARAMETER:template<|.each_byte {|byte|
            case byte
            when ?c, ?C
              len += 1
            when ?n
              len += 2
            when ?N
              len += 4
            else
              |>METHOD:raise<| StandardError.new("unsupported template: '#{byte.chr}' in '#{|>PARAMETER:template<|}'")
            end
          }
          |>METHOD:raise<| DecodeError.new("limit exceeded") if @limit < @index + len
          arr = @data.unpack("@#{@index}#{|>PARAMETER:template<|}")
          @index += len
          return arr
        end

        def |>METHOD:get_string<|
          len = @data[@index]
          |>METHOD:raise<| DecodeError.new("limit exceeded") if @limit < @index + 1 + len
          d = @data[@index + 1, len]
          @index += 1 + len
          return d
        end

        def |>METHOD:get_string_list<|
          strings = []
          while @index < @limit
            strings << self.get_string
          end
          strings
        end

        def |>METHOD:get_name<|
          return Name.new(self.get_labels)
        end

        def |>METHOD:get_labels<|(|>PARAMETER:limit<|=nil)
          |>PARAMETER:limit<| = @index if !|>PARAMETER:limit<| || @index < |>PARAMETER:limit<|
          d = []
          while true
            case @data[@index]
            when 0
              @index += 1
              return d
            when 192..255
              idx = self.get_unpack('n')[0] & 0x3fff
              if |>PARAMETER:limit<| <= idx
                |>METHOD:raise<| DecodeError.new("non-backward name pointer")
              end
              save_index = @index
              @index = idx
              d += self.get_labels(|>PARAMETER:limit<|)
              @index = save_index
              return d
            else
              d << self.get_label
            end
          end
          return d
        end

        def |>METHOD:get_label<|
          return Label::Str.new(self.get_string)
        end

        def |>METHOD:get_question<|
          name = self.get_name
          type, klass = self.get_unpack("nn")
          return name, Resource.get_class(type, klass)
        end

        def |>METHOD:get_rr<|
          name = self.get_name
          type, klass, ttl = self.get_unpack('nnN')
          typeclass = Resource.get_class(type, klass)
          return name, ttl, self.get_length16 {typeclass.decode_rdata(self)}
        end
      end
    end

    class Query
      def |>METHOD:encode_rdata<|(|>UNUSED:msg<|)
        |>METHOD:raise<| EncodeError.new("#{self.class} is query.") 
      end

      def self.|>METHOD:decode_rdata<|(|>UNUSED:msg<|)
        |>METHOD:raise<| DecodeError.new("#{self.class} is query.") 
      end
    end

    class Resource < Query
      ClassHash = {}

      def |>METHOD:encode_rdata<|(|>UNUSED:msg<|)
        |>METHOD:raise<| NotImplementedError.new
      end

      def self.|>METHOD:decode_rdata<|(|>UNUSED:msg<|)
        |>METHOD:raise<| NotImplementedError.new
      end

      def |>METHOD:==<|(|>PARAMETER:other<|)
        return self.class == |>PARAMETER:other<|.class &&
          self.instance_variables == |>PARAMETER:other<|.instance_variables &&
          self.instance_variables.collect {|name| self.instance_eval name} ==
          |>PARAMETER:other<|.instance_variables.collect {|name| |>PARAMETER:other<|.instance_eval name}
      end

      def |>METHOD:eql?<|(|>PARAMETER:other<|)
        return self == |>PARAMETER:other<|
      end

      def |>METHOD:hash<|
        h = 0
        self.instance_variables.each {|name|
          h ^= self.instance_eval("#{name}.hash")
        }
        return h
      end

      def self.|>METHOD:get_class<|(|>PARAMETER:type_value<|, |>PARAMETER:class_value<|)
        return ClassHash[[|>PARAMETER:type_value<|, |>PARAMETER:class_value<|]] ||
          Generic.create(|>PARAMETER:type_value<|, |>PARAMETER:class_value<|)
      end

      class Generic < Resource
        def |>METHOD:initialize<|(|>PARAMETER:data<|)
          @data = |>PARAMETER:data<|
        end
        |>METHOD:attr_reader<| :data

        def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
          |>PARAMETER:msg<|.put_bytes(|>METHOD:data<|)
        end

        def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
          return self.new(|>PARAMETER:msg<|.get_bytes)
        end

        def self.|>METHOD:create<|(|>PARAMETER:type_value<|, |>PARAMETER:class_value<|)
          c = Class.new(Generic)
          c.const_set(:TypeValue, |>PARAMETER:type_value<|)
          c.const_set(:ClassValue, |>PARAMETER:class_value<|)
          Generic.const_set("Type#{|>PARAMETER:type_value<|}_Class#{|>PARAMETER:class_value<|}", c)
          ClassHash[[|>PARAMETER:type_value<|, |>PARAMETER:class_value<|]] = c
          return c
        end
      end

      class DomainName < Resource
        def |>METHOD:initialize<|(|>PARAMETER:name<|)
          @name = |>PARAMETER:name<|
        end
        |>METHOD:attr_reader<| :name

        def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
          |>PARAMETER:msg<|.put_name(@name)
        end

        def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
          return self.new(|>PARAMETER:msg<|.get_name)
        end
      end

      # Standard (class generic) RRs
      ClassValue = nil

      class NS < DomainName
        TypeValue = 2
      end

      class CNAME < DomainName
        TypeValue = 5
      end

      class SOA < Resource
        TypeValue = 6

        def |>METHOD:initialize<|(|>PARAMETER:mname<|, |>PARAMETER:rname<|, |>PARAMETER:serial<|, |>PARAMETER:refresh<|, |>PARAMETER:retry_<|, |>PARAMETER:expire<|, |>PARAMETER:minimum<|)
          @mname = |>PARAMETER:mname<|
          @rname = |>PARAMETER:rname<|
          @serial = |>PARAMETER:serial<|
          @refresh = |>PARAMETER:refresh<|
          @retry = |>PARAMETER:retry_<|
          @expire = |>PARAMETER:expire<|
          @minimum = |>PARAMETER:minimum<|
        end
        |>METHOD:attr_reader<| :mname, :rname, :serial, :refresh, :retry, :expire, :minimum

        def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
          |>PARAMETER:msg<|.put_name(@mname)
          |>PARAMETER:msg<|.put_name(@rname)
          |>PARAMETER:msg<|.put_pack('NNNNN', @serial, @refresh, @retry, @expire, @minimum)
        end

        def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
          mname = |>PARAMETER:msg<|.get_name
          rname = |>PARAMETER:msg<|.get_name
          serial, refresh, retry_, expire, minimum = |>PARAMETER:msg<|.get_unpack('NNNNN')
          return self.new(
            mname, rname, serial, refresh, retry_, expire, minimum)
        end
      end

      class PTR < DomainName
        TypeValue = 12
      end

      class HINFO < Resource
        TypeValue = 13

        def |>METHOD:initialize<|(|>PARAMETER:cpu<|, |>PARAMETER:os<|)
          @cpu = |>PARAMETER:cpu<|
          @os = |>PARAMETER:os<|
        end
        |>METHOD:attr_reader<| :cpu, :os

        def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
          |>PARAMETER:msg<|.put_string(@cpu)
          |>PARAMETER:msg<|.put_string(@os)
        end

        def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
          cpu = |>PARAMETER:msg<|.get_string
          os = |>PARAMETER:msg<|.get_string
          return self.new(cpu, os)
        end
      end

      class MINFO < Resource
        TypeValue = 14

        def |>METHOD:initialize<|(|>PARAMETER:rmailbx<|, |>PARAMETER:emailbx<|)
          @rmailbx = |>PARAMETER:rmailbx<|
          @emailbx = |>PARAMETER:emailbx<|
        end
        |>METHOD:attr_reader<| :rmailbx, :emailbx

        def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
          |>PARAMETER:msg<|.put_name(@rmailbx)
          |>PARAMETER:msg<|.put_name(@emailbx)
        end

        def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
          rmailbx = |>PARAMETER:msg<|.get_string
          emailbx = |>PARAMETER:msg<|.get_string
          return self.new(rmailbx, emailbx)
        end
      end

      class MX < Resource
        TypeValue= 15

        def |>METHOD:initialize<|(|>PARAMETER:preference<|, |>PARAMETER:exchange<|)
          @preference = |>PARAMETER:preference<|
          @exchange = |>PARAMETER:exchange<|
        end
        |>METHOD:attr_reader<| :preference, :exchange

        def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
          |>PARAMETER:msg<|.put_pack('n', @preference)
          |>PARAMETER:msg<|.put_name(@exchange)
        end

        def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
          preference, = |>PARAMETER:msg<|.get_unpack('n')
          exchange = |>PARAMETER:msg<|.get_name
          return self.new(preference, exchange)
        end
      end

      class TXT < Resource
        TypeValue = 16

        def |>METHOD:initialize<|(|>PARAMETER:first_string<|, |>PARAMETER:*rest_strings<|)
          @strings = [|>PARAMETER:first_string<|, *|>PARAMETER:rest_strings<|]
        end
        |>METHOD:attr_reader<| :strings

        def |>METHOD:data<|
          @strings[0]
        end

        def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
          |>PARAMETER:msg<|.put_string_list(@strings)
        end

        def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
          strings = |>PARAMETER:msg<|.get_string_list
          return self.new(*strings)
        end
      end

      class ANY < Query
        TypeValue = 255
      end

      ClassInsensitiveTypes = [
        NS, CNAME, SOA, PTR, HINFO, MINFO, MX, TXT, ANY
      ]

      # ARPA Internet specific RRs
      module IN
        ClassValue = 1

        ClassInsensitiveTypes.each {|s|
          c = Class.new(s)
          c.const_set(:TypeValue, s::TypeValue)
          c.const_set(:ClassValue, ClassValue)
          ClassHash[[s::TypeValue, ClassValue]] = c
          self.const_set(s.name.sub(/.*::/, ''), c)
        }

        class A < Resource
          ClassHash[[TypeValue = 1, ClassValue = ClassValue]] = self

          def |>METHOD:initialize<|(|>PARAMETER:address<|)
            @address = IPv4.create(|>PARAMETER:address<|)
          end
          |>METHOD:attr_reader<| :address

          def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
            |>PARAMETER:msg<|.put_bytes(@address.address)
          end

          def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
            return self.new(IPv4.new(|>PARAMETER:msg<|.get_bytes(4)))
          end
        end

        class WKS < Resource
          ClassHash[[TypeValue = 11, ClassValue = ClassValue]] = self

          def |>METHOD:initialize<|(|>PARAMETER:address<|, |>PARAMETER:protocol<|, |>PARAMETER:bitmap<|)
            @address = IPv4.create(|>PARAMETER:address<|)
            @protocol = |>PARAMETER:protocol<|
            @bitmap = |>PARAMETER:bitmap<|
          end
          |>METHOD:attr_reader<| :address, :protocol, :bitmap

          def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
            |>PARAMETER:msg<|.put_bytes(@address.address)
            |>PARAMETER:msg<|.put_pack("n", @protocol)
            |>PARAMETER:msg<|.put_bytes(@bitmap)
          end

          def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
            address = IPv4.new(|>PARAMETER:msg<|.get_bytes(4))
            protocol, = |>PARAMETER:msg<|.get_unpack("n")
            bitmap = |>PARAMETER:msg<|.get_bytes
            return self.new(address, protocol, bitmap)
          end
        end

        class AAAA < Resource
          ClassHash[[TypeValue = 28, ClassValue = ClassValue]] = self

          def |>METHOD:initialize<|(|>PARAMETER:address<|)
            @address = IPv6.create(|>PARAMETER:address<|)
          end
          |>METHOD:attr_reader<| :address

          def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
            |>PARAMETER:msg<|.put_bytes(@address.address)
          end

          def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
            return self.new(IPv6.new(|>PARAMETER:msg<|.get_bytes(16)))
          end
        end

        # SRV resource record defined in RFC 2782
        # 
        # These records identify the hostname and port that a service is
        # available at.
        # 
        # The format is:
        #   _Service._Proto.Name TTL Class SRV Priority Weight Port Target
        #
        # The fields specific to SRV are defined in RFC 2782 as meaning:
        # - +priority+ The priority of this target host.  A client MUST attempt
        #   to contact the target host with the lowest-numbered priority it can
        #   reach; target hosts with the same priority SHOULD be tried in an
        #   order defined by the weight field.  The range is 0-65535.  Note that
        #   it is not widely implemented and should be set to zero.
        # 
        # - +weight+ A server selection mechanism.  The weight field specifies
        #   a relative weight for entries with the same priority. Larger weights
        #   SHOULD be given a proportionately higher probability of being
        #   selected. The range of this number is 0-65535.  Domain administrators
        #   SHOULD use Weight 0 when there isn't any server selection to do, to
        #   make the RR easier to read for humans (less noisy). Note that it is
        #   not widely implemented and should be set to zero.
        #
        # - +port+  The port on this target host of this service.  The range is 0-
        #   65535.
        # 
        # - +target+ The domain name of the target host. A target of "." means
        #   that the service is decidedly not available at this domain.
        class SRV < Resource
          ClassHash[[TypeValue = 33, ClassValue = ClassValue]] = self

          # Create a SRV resource record.
          def |>METHOD:initialize<|(|>PARAMETER:priority<|, |>PARAMETER:weight<|, |>PARAMETER:port<|, |>PARAMETER:target<|)
            @priority = |>PARAMETER:priority<|.to_int
            @weight = |>PARAMETER:weight<|.to_int
            @port = |>PARAMETER:port<|.to_int
            @target = Name.create(|>PARAMETER:target<|)
          end

          |>METHOD:attr_reader<| :priority, :weight, :port, :target

          def |>METHOD:encode_rdata<|(|>PARAMETER:msg<|)
            |>PARAMETER:msg<|.put_pack("n", @priority)
            |>PARAMETER:msg<|.put_pack("n", @weight)
            |>PARAMETER:msg<|.put_pack("n", @port)
            |>PARAMETER:msg<|.put_name(@target)
          end

          def self.|>METHOD:decode_rdata<|(|>PARAMETER:msg<|)
            priority, = |>PARAMETER:msg<|.get_unpack("n")
            weight,   = |>PARAMETER:msg<|.get_unpack("n")
            port,     = |>PARAMETER:msg<|.get_unpack("n")
            target    = |>PARAMETER:msg<|.get_name
            return self.new(priority, weight, port, target)
          end
        end

      end
    end
  end

  class IPv4
    Regex = /\A(\d+)\.(\d+)\.(\d+)\.(\d+)\z/

    def self.|>METHOD:create<|(|>PARAMETER:arg<|)
      case |>PARAMETER:arg<|
      when IPv4
        return |>PARAMETER:arg<|
      when Regex
        if (0..255) === (a = $1.to_i) &&
            (0..255) === (b = $2.to_i) &&
            (0..255) === (c = $3.to_i) &&
            (0..255) === (d = $4.to_i)
          return self.new([a, b, c, d].pack("CCCC"))
        else
          |>METHOD:raise<| ArgumentError.new("IPv4 address with invalid value: " + |>PARAMETER:arg<|)
        end
      else
        |>METHOD:raise<| ArgumentError.new("cannot interpret as IPv4 address: #{|>PARAMETER:arg<|.inspect}")
      end
    end

    def |>METHOD:initialize<|(|>PARAMETER:address<|)
      unless |>PARAMETER:address<|.kind_of?(String) && |>PARAMETER:address<|.length == 4
        |>METHOD:raise<| ArgumentError.new('IPv4 address must be 4 bytes')
      end
      @address = |>PARAMETER:address<|
    end
    |>METHOD:attr_reader<| :address

    def |>METHOD:to_s<|
      return |>METHOD:sprintf<|("%d.%d.%d.%d", *@address.unpack("CCCC"))
    end

    def |>METHOD:inspect<|
      return "#<#{self.class} #{self.to_s}>"
    end

    def |>METHOD:to_name<|
      return DNS::Name.create(
        '%d.%d.%d.%d.in-addr.arpa.' % @address.unpack('CCCC').reverse)
    end

    def |>METHOD:==<|(|>PARAMETER:other<|)
      return @address == |>PARAMETER:other<|.address
    end

    def |>METHOD:eql?<|(|>PARAMETER:other<|)
      return self == |>PARAMETER:other<|
    end

    def |>METHOD:hash<|
      return @address.hash
    end
  end

  class IPv6
    Regex_8Hex = /\A
      (?:[0-9A-Fa-f]{1,4}:){7}
         [0-9A-Fa-f]{1,4}
      \z/x

    Regex_CompressedHex = /\A
      ((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?) ::
      ((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?)
      \z/x

    Regex_6Hex4Dec = /\A
      ((?:[0-9A-Fa-f]{1,4}:){6,6})
      (\d+)\.(\d+)\.(\d+)\.(\d+)
      \z/x

    Regex_CompressedHex4Dec = /\A
      ((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?) ::
      ((?:[0-9A-Fa-f]{1,4}:)*)
      (\d+)\.(\d+)\.(\d+)\.(\d+)
      \z/x

    Regex = /
      (?:#{Regex_8Hex}) |
      (?:#{Regex_CompressedHex}) |
      (?:#{Regex_6Hex4Dec}) |
      (?:#{Regex_CompressedHex4Dec})/x

    def self.|>METHOD:create<|(|>PARAMETER:arg<|)
      case |>PARAMETER:arg<|
      when IPv6
        return |>PARAMETER:arg<|
      when String
        address = ''
        if Regex_8Hex =~ |>PARAMETER:arg<|
          |>PARAMETER:arg<|.scan(/[0-9A-Fa-f]+/) {|hex| address << [hex.hex].pack('n')}
        elsif Regex_CompressedHex =~ |>PARAMETER:arg<|
          prefix = $1
          suffix = $2
          a1 = ''
          a2 = ''
          prefix.scan(/[0-9A-Fa-f]+/) {|hex| a1 << [hex.hex].pack('n')}
          suffix.scan(/[0-9A-Fa-f]+/) {|hex| a2 << [hex.hex].pack('n')}
          omitlen = 16 - a1.length - a2.length
          address << a1 << "\0" * omitlen << a2
        elsif Regex_6Hex4Dec =~ |>PARAMETER:arg<|
          prefix, a, b, c, d = $1, $2.to_i, $3.to_i, $4.to_i, $5.to_i
          if (0..255) === a && (0..255) === b && (0..255) === c && (0..255) === d
            prefix.scan(/[0-9A-Fa-f]+/) {|hex| address << [hex.hex].pack('n')}
            address << [a, b, c, d].pack('CCCC')
          else
            |>METHOD:raise<| ArgumentError.new("not numeric IPv6 address: " + |>PARAMETER:arg<|)
          end
        elsif Regex_CompressedHex4Dec =~ |>PARAMETER:arg<|
          prefix, suffix, a, b, c, d = $1, $2, $3.to_i, $4.to_i, $5.to_i, $6.to_i
          if (0..255) === a && (0..255) === b && (0..255) === c && (0..255) === d
            a1 = ''
            a2 = ''
            prefix.scan(/[0-9A-Fa-f]+/) {|hex| a1 << [hex.hex].pack('n')}
            suffix.scan(/[0-9A-Fa-f]+/) {|hex| a2 << [hex.hex].pack('n')}
            omitlen = 12 - a1.length - a2.length
            address << a1 << "\0" * omitlen << a2 << [a, b, c, d].pack('CCCC')
          else
            |>METHOD:raise<| ArgumentError.new("not numeric IPv6 address: " + |>PARAMETER:arg<|)
          end
        else
          |>METHOD:raise<| ArgumentError.new("not numeric IPv6 address: " + |>PARAMETER:arg<|)
        end
        return IPv6.new(address)
      else
        |>METHOD:raise<| ArgumentError.new("cannot interpret as IPv6 address: #{|>PARAMETER:arg<|.inspect}")
      end
    end

    def |>METHOD:initialize<|(|>PARAMETER:address<|)
      unless |>PARAMETER:address<|.kind_of?(String) && |>PARAMETER:address<|.length == 16
        |>METHOD:raise<| ArgumentError.new('IPv6 address must be 16 bytes')
      end
      @address = |>PARAMETER:address<|
    end
    |>METHOD:attr_reader<| :address

    def |>METHOD:to_s<|
      address = |>METHOD:sprintf<|("%X:%X:%X:%X:%X:%X:%X:%X", *@address.unpack("nnnnnnnn"))
      unless address.sub!(/(^|:)0(:0)+(:|$)/, '::')
        address.sub!(/(^|:)0(:|$)/, '::')
      end
      return address
    end

    def |>METHOD:inspect<|
      return "#<#{self.class} #{self.to_s}>"
    end

    def |>METHOD:to_name<|
      # ip6.arpa should be searched too. [RFC3152]
      return DNS::Name.new(
        @address.unpack("H32")[0].split(//).reverse + ['ip6', 'int'])
    end

    def |>METHOD:==<|(|>PARAMETER:other<|)
      return @address == |>PARAMETER:other<|.address
    end

    def |>METHOD:eql?<|(|>PARAMETER:other<|)
      return self == |>PARAMETER:other<|
    end

    def |>METHOD:hash<|
      return @address.hash
    end
  end

  DefaultResolver = self.new
  AddressRegex = /(?:#{IPv4::Regex})|(?:#{IPv6::Regex})/
end
