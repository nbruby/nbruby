<html><body>
<hr>
<br/>
date.rb - date and time library <br><br>Author: Tadayoshi Funaba 1998-2006 <br><br>Documentation: William Webber <william@williamwebber.com> <br><h2> Overview</h2>
This file provides two classes for working with dates and times. <br><br>The first class, Date, represents dates.  It works with years, months, weeks, and days. See the Date class documentation for more details. <br><br>The second, DateTime, extends Date to include hours, minutes, seconds, and fractions of a second.  It provides basic support for time zones.  See the DateTime class documentation for more details. <br><h3> Ways of calculating the date.</h3>
In common usage, the date is reckoned in years since or before the Common Era (CE/BCE, also known as AD/BC), then as a month and day-of-the-month within the current year. This is known as the <b>Civil</b> <b>Date</b>, and abbreviated as <tt>civil</tt> in the Date class. <br><br>Instead of year, month-of-the-year,  and day-of-the-month, the date can also be reckoned in terms of year and day-of-the-year.  This is known as the <b>Ordinal</b> <b>Date</b>, and is abbreviated as <tt>ordinal</tt> in the Date class.  (Note that referring to this as the Julian date is incorrect.) <br><br>The date can also be reckoned in terms of year, week-of-the-year, and day-of-the-week.  This is known as the <b>Commercial</b> <b>Date</b>, and is abbreviated as <tt>commercial</tt> in the Date class.  The commercial week runs Monday (day-of-the-week 1) to Sunday (day-of-the-week 7), in contrast to the civil week which runs Sunday (day-of-the-week 0) to Saturday (day-of-the-week 6).  The first week of the commercial year starts on the Monday on or before January 1, and the commercial year itself starts on this Monday, not January 1. <br><br>For scientific purposes, it is convenient to refer to a date simply as a day count, counting from an arbitrary initial day.  The date first chosen for this was January 1, 4713 BCE. A count of days from this date is the <b>Julian</b> <b>Day</b> <b>Number</b> or <b>Julian</b> <b>Date</b>, which is abbreviated as <tt>jd</tt> in the Date class.  This is in local time, and counts from midnight on the initial day.  The stricter usage is in UTC, and counts from midday on the initial day.  This is referred to in the Date class as the <b>Astronomical</b> <b>Julian</b> <b>Day</b> <b>Number</b>, and abbreviated as <tt>ajd</tt>.  In the Date class, the Astronomical Julian Day Number includes fractional days. <br><br>Another absolute day count is the <b>Modified</b> <b>Julian</b> <b>Day</b> <b>Number</b>, which takes November 17, 1858 as its initial day. This is abbreviated as <tt>mjd</tt> in the Date class.  There is also an <b>Astronomical</b> <b>Modified</b> <b>Julian</b> <b>Day</b> <b>Number</b>, which is in UTC and includes fractional days.  This is abbreviated as <tt>amjd</tt> in the Date class.  Like the Modified Julian Day Number (and unlike the Astronomical Julian Day Number), it counts from midnight. <br><br>Alternative calendars such as the Chinese Lunar Calendar, the Islamic Calendar, or the French Revolutionary Calendar are not supported by the Date class; nor are calendars that are based on an Era different from the Common Era, such as the Japanese Imperial Calendar or the Republic of China Calendar. <br><h3> Calendar Reform</h3>
The standard civil year is 365 days long.  However, the solar year is fractionally longer than this.  To account for this, a <b>leap</b> <b>year</b> is occasionally inserted.  This is a year with 366 days, the extra day falling on February 29.  In the early days of the civil calendar, every fourth year without exception was a leap year.  This way of reckoning leap years is the <b>Julian</b> <b>Calendar</b>. <br><br>However, the solar year is marginally shorter than 365 1/4 days, and so the <b>Julian</b> <b>Calendar</b> gradually ran slow over the centuries.  To correct this, every 100th year (but not every 400th year) was excluded as a leap year. This way of reckoning leap years, which we use today, is the <b>Gregorian</b> <b>Calendar</b>. <br><br>The Gregorian Calendar was introduced at different times in different regions.  The day on which it was introduced for a particular region is the <b>Day</b> <b>of</b> <b>Calendar</b> <b>Reform</b> for that region.  This is abbreviated as <tt>sg</tt> (for Start of Gregorian calendar) in the Date class. <br><br>Two such days are of particular significance.  The first is October 15, 1582, which was the Day of Calendar Reform for Italy and most Catholic countries.  The second is September 14, 1752, which was the Day of Calendar Reform for England and its colonies (including what is now the United States).  These two dates are available as the constants Date::ITALY and Date::ENGLAND, respectively.  (By comparison, Germany and Holland, less Catholic than Italy but less stubborn than England, changed over in 1698; Sweden in 1753; Russia not till 1918, after the Revolution; and Greece in 1923.  Many Orthodox churches still use the Julian Calendar.  A complete list of Days of Calendar Reform can be found at <a href="http://www.polysyllabic.com/GregConv.html.">http://www.polysyllabic.com/GregConv.html.</a>) <br><br>Switching from the Julian to the Gregorian calendar involved skipping a number of days to make up for the accumulated lag, and the later the switch was (or is) done, the more days need to be skipped.  So in 1582 in Italy, 4th October was followed by 15th October, skipping 10 days; in 1752 in England, 2nd September was followed by 14th September, skipping 11 days; and if I decided to switch from Julian to Gregorian Calendar this midnight, I would go from 27th July 2003 (Julian) today to 10th August 2003 (Gregorian) tomorrow, skipping 13 days.  The Date class is aware of this gap, and a supposed date that would fall in the middle of it is regarded as invalid. <br><br>The Day of Calendar Reform is relevant to all date representations involving years.  It is not relevant to the Julian Day Numbers, except for converting between them and year-based representations. <br><br>In the Date and DateTime classes, the Day of Calendar Reform or <tt>sg</tt> can be specified a number of ways.  First, it can be as the Julian Day Number of the Day of Calendar Reform.  Second, it can be using the constants Date::ITALY or Date::ENGLAND; these are in fact the Julian Day Numbers of the Day of Calendar Reform of the respective regions.  Third, it can be as the constant Date::JULIAN, which means to always use the Julian Calendar. Finally, it can be as the constant Date::GREGORIAN, which means to always use the Gregorian Calendar. <br><br>Note: in the Julian Calendar, New Years Day was March 25.  The Date class does not follow this convention. <br><h3> Time Zones</h3>
DateTime objects support a simple representation of time zones.  Time zones are represented as an offset from UTC, as a fraction of a day.  This offset is the how much local time is later (or earlier) than UTC. UTC offset 0 is centred on England (also known as GMT).  As you travel east, the offset increases until you reach the dateline in the middle of the Pacific Ocean; as you travel west, the offset decreases.  This offset is abbreviated as <tt>of</tt> in the Date class. <br><br>This simple representation of time zones does not take into account the common practice of Daylight Savings Time or Summer Time. <br><br>Most DateTime methods return the date and the time in local time.  The two exceptions are <a href="#ajd">ajd</a>() and <a href="#amjd">amjd</a>(), which return the date and time in UTC time, including fractional days. <br><br>The Date class does not support time zone offsets, in that there is no way to create a Date object with a time zone. However, methods of the Date class when used by a DateTime instance will use the time zone offset of this instance. <br><h2> Examples of use</h2>
<h3> Print out the date of every Sunday between two dates.</h3>
<pre style="color:#000000;">
    <span style="color:#0000e6;">def</span> <span style="">print_sundays</span><span style="">(</span><span style="">d1</span><span style="">,</span> <span style="">d2</span><span style="">)</span><br>        <span style="">d1</span> <span style="">+=</span><span style="color:#000000;">1</span> <span style="color:#0000e6;">while</span> <span style="">(</span><span style="">d1</span><span style="">.</span><span style="">wday</span> <span style="">!=</span> <span style="color:#000000;">0</span><span style="">)</span><br>        <span style="">d1</span><span style="">.</span><span style="">step</span><span style="">(</span><span style="">d2</span><span style="">,</span> <span style="color:#000000;">7</span><span style="">)</span> <span style="color:#0000e6;">do</span> <span style="">|</span><span style="">date</span><span style="">|</span><br>            <span style="">puts</span> <span style="color:#ce7b00;">"</span><span style="color:#ce7b00"><span style="color:#ce7b00;">#{</span></span><span style="background:#ffffff;color:#000000"><span style="color:#000000;font-style:italic;">Date</span><span style="">::</span><span style="color:#000000;font-style:italic;">MONTHNAMES</span><span style="">[</span><span style="">date</span><span style="">.</span><span style="">mon</span><span style="">]</span></span><span style="color:#ce7b00"><span style="color:#ce7b00;">}</span></span><span style="color:#ce7b00"><span style="color:#ce7b00;"> </span></span><span style="color:#ce7b00"><span style="color:#ce7b00;">#{</span></span><span style="background:#ffffff;color:#000000"><span style="">date</span><span style="">.</span><span style="">day</span></span><span style="color:#ce7b00"><span style="color:#ce7b00;">}</span></span><span style="color:#ce7b00;">"</span><br>        <span style="color:#0000e6;">end</span><br>    <span style="color:#0000e6;">end</span><br></pre>
<pre style="color:#000000;">
    <span style="">print_sundays</span><span style="">(</span><span style="color:#000000;font-style:italic;">Date</span><span style="">::</span><span style="">civil</span><span style="">(</span><span style="color:#000000;">2003</span><span style="">,</span> <span style="color:#000000;">4</span><span style="">,</span> <span style="color:#000000;">8</span><span style="">)</span><span style="">,</span> <span style="color:#000000;font-style:italic;">Date</span><span style="">::</span><span style="">civil</span><span style="">(</span><span style="color:#000000;">2003</span><span style="">,</span> <span style="color:#000000;">5</span><span style="">,</span> <span style="color:#000000;">23</span><span style="">)</span><span style="">)</span><br></pre>
<h3> Calculate how many seconds to go till midnight on New Year's Day.</h3>
<pre style="color:#000000;">
    <span style="color:#0000e6;">def</span> <span style="">secs_to_new_year</span><span style="">(</span><span style="">now</span> <span style="">=</span> <span style="color:#000000;font-style:italic;">DateTime</span><span style="">::</span><span style="">now</span><span style="">(</span><span style="">)</span><span style="">)</span><br>        <span style="">new_year</span> <span style="">=</span> <span style="color:#000000;font-style:italic;">DateTime</span><span style="">.</span><span style="">new</span><span style="">(</span><span style="">now</span><span style="">.</span><span style="">year</span> <span style="">+</span> <span style="color:#000000;">1</span><span style="">,</span> <span style="color:#000000;">1</span><span style="">,</span> <span style="color:#000000;">1</span><span style="">)</span><br>        <span style="">dif</span> <span style="">=</span> <span style="">new_year</span> <span style="">-</span> <span style="">now</span><br>        <span style="">hours</span><span style="">,</span> <span style="">mins</span><span style="">,</span> <span style="">secs</span><span style="">,</span> <span style="">ignore_fractions</span> <span style="">=</span> <span style="color:#000000;font-style:italic;">Date</span><span style="">::</span><span style="">day_fraction_to_time</span><span style="">(</span><span style="">dif</span><span style="">)</span><br>        <span style="color:#0000e6;">return</span> <span style="">hours</span> <span style="">*</span> <span style="color:#000000;">60</span> <span style="">*</span> <span style="color:#000000;">60</span> <span style="">+</span> <span style="">mins</span> <span style="">*</span> <span style="color:#000000;">60</span> <span style="">+</span> <span style="">secs</span><br>    <span style="color:#0000e6;">end</span><br></pre>
<pre style="color:#000000;">
    <span style="">puts</span> <span style="">secs_to_new_year</span><span style="">(</span><span style="">)</span><br></pre>
<hr>
<pre>class Date</pre><br/>
Class representing a date. <br><br>See the documentation to the file date.rb for an overview. <br><br>Internally, the date is represented as an Astronomical Julian Day Number, <tt>ajd</tt>.  The Day of Calendar Reform, <tt>sg</tt>, is also stored, for conversions to other date formats.  (There is also an <tt>of</tt> field for a time zone offset, but this is only for the use of the DateTime subclass.) <br><br>A new Date object is created using one of the object creation class methods named after the corresponding date format, and the arguments appropriate to that date format; for instance, Date::civil() (aliased to Date::new()) with year, month, and day-of-month, or Date::ordinal() with year and day-of-year. All of these object creation class methods also take the Day of Calendar Reform as an optional argument. <br><br>Date objects are immutable once created. <br><br>Once a Date has been created, date values can be retrieved for the different date formats supported using instance methods.  For instance, <a href="#mon">mon</a>() gives the Civil month, <a href="#cwday">cwday</a>() gives the Commercial day of the week, and <a href="#yday">yday</a>() gives the Ordinal day of the year.  Date values can be retrieved in any format, regardless of what format was used to create the Date instance. <br><br>The Date class includes the Comparable module, allowing date objects to be compared and sorted, ranges of dates to be created, and so forth. <hr>
<pre>  MONTHNAMES = [nil] + %w(January February March April May June July</pre><br/>
Full month names, in English.  Months count from 1 to 12; a month's numerical representation indexed into this array gives the name of that month (hence the first element is nil). <hr>
<pre>  DAYNAMES = %w(Sunday Monday Tuesday Wednesday Thursday Friday Saturday)</pre><br/>
Full names of days of the week, in English.  Days of the week count from 0 to 6 (except in the commercial week); a day's numerical representation indexed into this array gives the name of that day. <hr>
<pre>  ABBR_MONTHNAMES = [nil] + %w(Jan Feb Mar Apr May Jun</pre><br/>
Abbreviated month names, in English. <hr>
<pre>  ABBR_DAYNAMES = %w(Sun Mon Tue Wed Thu Fri Sat)</pre><br/>
Abbreviated day names, in English. <hr>
<pre>  ITALY     = 2299161 # 1582-10-15</pre><br/>
The Julian Day Number of the Day of Calendar Reform for Italy and the Catholic countries. <hr>
<pre>  ENGLAND   = 2361222 # 1752-09-14</pre><br/>
The Julian Day Number of the Day of Calendar Reform for England and her Colonies. <hr>
<pre>  JULIAN    = false</pre><br/>
A constant used to indicate that a Date should always use the Julian calendar. <hr>
<pre>  GREGORIAN = true</pre><br/>
A constant used to indicate that a Date should always use the Gregorian calendar. <hr>
<pre>  def self.os? (jd, sg)</pre><br/>
Does a given Julian Day Number fall inside the old-style (Julian) calendar? <br><br><tt>jd</tt> is the Julian Day Number in question. <tt>sg</tt> may be Date::GREGORIAN, in which case the answer is false; it may be Date::JULIAN, in which case the answer is true; or it may a number representing the Day of Calendar Reform. Date::ENGLAND and Date::ITALY are two possible such days. <hr>
<pre>  def self.ns? (jd, sg) not os?(jd, sg) end</pre><br/>
Does a given Julian Day Number fall inside the new-style (Gregorian) calendar? <br><br>The reverse of self.os?  See the documentation for that method for more details. <hr>
<pre>  def self.civil_to_jd(y, m, d, sg=GREGORIAN)</pre><br/>
Convert a Civil Date to a Julian Day Number. <tt>y</tt>, <tt>m</tt>, and <tt>d</tt> are the year, month, and day of the month.  <tt>sg</tt> specifies the Day of Calendar Reform. <br><br>Returns the corresponding Julian Day Number. <hr>
<pre>  def self.jd_to_civil(jd, sg=GREGORIAN)</pre><br/>
Convert a Julian Day Number to a Civil Date.  <tt>jd</tt> is the Julian Day Number. <tt>sg</tt> specifies the Day of Calendar Reform. <br><br>Returns the corresponding [year, month, day_of_month] as a three-element array. <hr>
<pre>  def self.ordinal_to_jd(y, d, sg=GREGORIAN)</pre><br/>
Convert an Ordinal Date to a Julian Day Number. <br><br><tt>y</tt> and <tt>d</tt> are the year and day-of-year to convert. <tt>sg</tt> specifies the Day of Calendar Reform. <br><br>Returns the corresponding Julian Day Number. <hr>
<pre>  def self.jd_to_ordinal(jd, sg=GREGORIAN)</pre><br/>
Convert a Julian Day Number to an Ordinal Date. <br><br><tt>jd</tt> is the Julian Day Number to convert. <tt>sg</tt> specifies the Day of Calendar Reform. <br><br>Returns the corresponding Ordinal Date as [year, day_of_year] <hr>
<pre>  def self.jd_to_commercial(jd, sg=GREGORIAN)</pre><br/>
Convert a Julian Day Number to a Commercial Date <br><br><tt>jd</tt> is the Julian Day Number to convert. <tt>sg</tt> specifies the Day of Calendar Reform. <br><br>Returns the corresponding Commercial Date as [commercial_year, week_of_year, day_of_week] <hr>
<pre>  def self.commercial_to_jd(y, w, d, ns=GREGORIAN)</pre><br/>
Convert a Commercial Date to a Julian Day Number. <br><br><tt>y</tt>, <tt>w</tt>, and <tt>d</tt> are the (commercial) year, week of the year, and day of the week of the Commercial Date to convert. <tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.ajd_to_jd(ajd, of=0) clfloor(ajd + of + 1.to_r/2) end</pre><br/>
Convert an Astronomical Julian Day Number to a (civil) Julian Day Number. <br><br><tt>ajd</tt> is the Astronomical Julian Day Number to convert.  <tt>of</tt> is the offset from UTC as a fraction of a day (defaults to 0). <br><br>Returns the (civil) Julian Day Number as [day_number, fraction] where <tt>fraction</tt> is always 1/2. <hr>
<pre>  def self.jd_to_ajd(jd, fr, of=0) jd + fr - of - 1.to_r/2 end</pre><br/>
Convert a (civil) Julian Day Number to an Astronomical Julian Day Number. <br><br><tt>jd</tt> is the Julian Day Number to convert, and <tt>fr</tt> is a fractional day.  <tt>of</tt> is the offset from UTC as a fraction of a day (defaults to 0). <br><br>Returns the Astronomical Julian Day Number as a single numeric value. <hr>
<pre>  def self.day_fraction_to_time(fr)</pre><br/>
Convert a fractional day <tt>fr</tt> to [hours, minutes, seconds, fraction_of_a_second] <hr>
<pre>  def self.time_to_day_fraction(h, min, s)</pre><br/>
Convert an <tt>h</tt> hour, <tt>min</tt> minutes, <tt>s</tt> seconds period to a fractional day. <hr>
<pre>  def self.amjd_to_ajd(amjd) amjd + 4800001.to_r/2 end</pre><br/>
Convert an Astronomical Modified Julian Day Number to an Astronomical Julian Day Number. <hr>
<pre>  def self.ajd_to_amjd(ajd) ajd - 4800001.to_r/2 end</pre><br/>
Convert an Astronomical Julian Day Number to an Astronomical Modified Julian Day Number. <hr>
<pre>  def self.mjd_to_jd(mjd) mjd + 2400001 end</pre><br/>
Convert a Modified Julian Day Number to a Julian Day Number. <hr>
<pre>  def self.jd_to_mjd(jd) jd - 2400001 end</pre><br/>
Convert a Julian Day Number to a Modified Julian Day Number. <hr>
<pre>  def self.ld_to_jd(ld) ld + 2299160 end</pre><br/>
Convert a count of the number of days since the adoption of the Gregorian Calendar (in Italy) to a Julian Day Number. <hr>
<pre>  def self.jd_to_ld(jd) jd - 2299160 end</pre><br/>
Convert a Julian Day Number to the number of days since the adoption of the Gregorian Calendar (in Italy). <hr>
<pre>  def self.jd_to_wday(jd) (jd + 1) % 7 end</pre><br/>
Convert a Julian Day Number to the day of the week. <br><br>Sunday is day-of-week 0; Saturday is day-of-week 6. <hr>
<pre>  def self.julian_leap? (y) y % 4 == 0 end</pre><br/>
Is a year a leap year in the Julian calendar? <br><br>All years divisible by 4 are leap years in the Julian calendar. <hr>
<pre>  def self.gregorian_leap? (y) y % 4 == 0 and y % 100 != 0 or y % 400 == 0 end</pre><br/>
Is a year a leap year in the Gregorian calendar? <br><br>All years divisible by 4 are leap years in the Gregorian calendar, except for years divisible by 100 and not by 400. <hr>
<pre>  def self.valid_jd? (jd, sg=ITALY) jd end</pre><br/>
Is <tt>jd</tt> a valid Julian Day Number? <br><br>If it is, returns it.  In fact, any value is treated as a valid Julian Day Number. <hr>
<pre>  def self.jd(jd=0, sg=ITALY)</pre><br/>
Create a new Date object from a Julian Day Number. <br><br><tt>jd</tt> is the Julian Day Number; if not specified, it defaults to <ol>
<li value="0"> <tt>sg</tt> specifies the Day of Calendar Reform. </ol>
<hr>
<pre>  def self.valid_ordinal? (y, d, sg=ITALY)</pre><br/>
Do the year <tt>y</tt> and day-of-year <tt>d</tt> make a valid Ordinal Date? Returns the corresponding Julian Day Number if they do, or nil if they don't. <br><br><tt>d</tt> can be a negative number, in which case it counts backwards from the end of the year (-1 being the last day of the year). No year wraparound is performed, however, so valid values of <tt>d</tt> are -365 .. -1, 1 .. 365 on a non-leap-year, -366 .. -1, 1 .. 366 on a leap year.  A date falling in the period skipped in the Day of Calendar Reform adjustment is not valid. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.ordinal(y=-4712, d=1, sg=ITALY)</pre><br/>
Create a new Date object from an Ordinal Date, specified by year <tt>y</tt> and day-of-year <tt>d</tt>. <tt>d</tt> can be negative, in which it counts backwards from the end of the year. No year wraparound is performed, however.  An invalid value for <tt>d</tt> results in an ArgumentError being raised. <br><br><tt>y</tt> defaults to -4712, and <tt>d</tt> to 1; this is Julian Day Number day 0. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.valid_civil? (y, m, d, sg=ITALY)</pre><br/>
Do year <tt>y</tt>, month <tt>m</tt>, and day-of-month <tt>d</tt> make a valid Civil Date?  Returns the corresponding Julian Day Number if they do, nil if they don't. <br><br><tt>m</tt> and <tt>d</tt> can be negative, in which case they count backwards from the end of the year and the end of the month respectively.  No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. A date falling in the period skipped in the Day of Calendar Reform adjustment is not valid. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.civil(y=-4712, m=1, d=1, sg=ITALY)</pre><br/>
Create a new Date object for the Civil Date specified by year <tt>y</tt>, month <tt>m</tt>, and day-of-month <tt>d</tt>. <br><br><tt>m</tt> and <tt>d</tt> can be negative, in which case they count backwards from the end of the year and the end of the month respectively.  No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. can be negative <br><br><tt>y</tt> defaults to -4712, <tt>m</tt> to 1, and <tt>d</tt> to 1; this is Julian Day Number day 0. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.valid_commercial? (y, w, d, sg=ITALY)</pre><br/>
Do year <tt>y</tt>, week-of-year <tt>w</tt>, and day-of-week <tt>d</tt> make a valid Commercial Date?  Returns the corresponding Julian Day Number if they do, nil if they don't. <br><br>Monday is day-of-week 1; Sunday is day-of-week 7. <br><br><tt>w</tt> and <tt>d</tt> can be negative, in which case they count backwards from the end of the year and the end of the week respectively.  No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. A date falling in the period skipped in the Day of Calendar Reform adjustment is not valid. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.commercial(y=1582, w=41, d=5, sg=ITALY)</pre><br/>
Create a new Date object for the Commercial Date specified by year <tt>y</tt>, week-of-year <tt>w</tt>, and day-of-week <tt>d</tt>. <br><br>Monday is day-of-week 1; Sunday is day-of-week 7. <br><br><tt>w</tt> and <tt>d</tt> can be negative, in which case they count backwards from the end of the year and the end of the week respectively.  No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. <br><br><tt>y</tt> defaults to 1582, <tt>w</tt> to 41, and <tt>d</tt> to 5, the Day of Calendar Reform for Italy and the Catholic countries. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.strptime(str='-4712-01-01', fmt='%F', sg=ITALY)</pre><br/>
Create a new Date object by parsing from a String according to a specified format. <br><br><tt>str</tt> is a String holding a date representation. <tt>fmt</tt> is the format that the date is in.  See date/format.rb for details on supported formats. <br><br>The default <tt>str</tt> is '-4712-01-01', and the default <tt>fmt</tt> is '%F', which means Year-Month-Day_of_Month. This gives Julian Day Number day 0. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <br><br>An ArgumentError will be raised if <tt>str</tt> cannot be parsed. <hr>
<pre>  def self.parse(str='-4712-01-01', comp=false, sg=ITALY)</pre><br/>
Create a new Date object by parsing from a String, without specifying the format. <br><br><tt>str</tt> is a String holding a date representation.  <tt>comp</tt> specifies whether to interpret 2-digit years as 19XX (>= 69) or 20XX (&lt; 69); the default is not to. The method will attempt to parse a date from the String using various heuristics; see <a href="#_parse">_parse</a> in date/format.rb for more details.  If parsing fails, an ArgumentError will be raised. <br><br>The default <tt>str</tt> is '-4712-01-01'; this is Julian Day Number day 0. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.today(sg=ITALY)</pre><br/>
Create a new Date object representing today. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def initialize(ajd=0, of=0, sg=ITALY) @ajd, @of, @sg = ajd, of, sg end</pre><br/>
<b>NOTE</b> this is the documentation for the method new0().  If you are reading this as the documentation for new(), that is because rdoc doesn't fully support the aliasing of the initialize() method. new() is in fact an alias for <a href="#civil">civil</a>(): read the documentation for that method instead. <br><br>Create a new Date object. <br><br><tt>ajd</tt> is the Astronomical Julian Day Number. <tt>of</tt> is the offset from UTC as a fraction of a day. Both default to 0. <br><br><tt>sg</tt> specifies the Day of Calendar Reform to use for this Date object. <br><br>Using one of the factory methods such as Date::civil is generally easier and safer. <hr>
<pre>  def ajd() @ajd end</pre><br/>
Get the date as an Astronomical Julian Day Number. <hr>
<pre>  def amjd() self.class.ajd_to_amjd(@ajd) end</pre><br/>
Get the date as an Astronomical Modified Julian Day Number. <hr>
<pre>  def jd() self.class.ajd_to_jd(@ajd, @of)[0] end</pre><br/>
Get the date as a Julian Day Number. <hr>
<pre>  def day_fraction() self.class.ajd_to_jd(@ajd, @of)[1] end</pre><br/>
Get any fractional day part of the date. <hr>
<pre>  def mjd() self.class.jd_to_mjd(jd) end</pre><br/>
Get the date as a Modified Julian Day Number. <hr>
<pre>  def ld() self.class.jd_to_ld(jd) end</pre><br/>
Get the date as the number of days since the Day of Calendar Reform (in Italy and the Catholic countries). <hr>
<pre>  def civil() self.class.jd_to_civil(jd, @sg) end</pre><br/>
Get the date as a Civil Date, [year, month, day_of_month] <hr>
<pre>  def ordinal() self.class.jd_to_ordinal(jd, @sg) end</pre><br/>
Get the date as an Ordinal Date, [year, day_of_year] <hr>
<pre>  def commercial() self.class.jd_to_commercial(jd, @sg) end</pre><br/>
Get the date as a Commercial Date, [year, week_of_year, day_of_week] <hr>
<pre>  def year() civil[0] end</pre><br/>
Get the year of this date. <hr>
<pre>  def yday() ordinal[1] end</pre><br/>
Get the day-of-the-year of this date. <br><br>January 1 is day-of-the-year 1 <hr>
<pre>  def mon() civil[1] end</pre><br/>
Get the month of this date. <br><br>January is month 1. <hr>
<pre>  def mday() civil[2] end</pre><br/>
Get the day-of-the-month of this date. <hr>
<pre>  def time() self.class.day_fraction_to_time(day_fraction) end</pre><br/>
Get the time of this date as [hours, minutes, seconds, fraction_of_a_second] <hr>
<pre>  def hour() time[0] end</pre><br/>
Get the hour of this date. <hr>
<pre>  def min() time[1] end</pre><br/>
Get the minute of this date. <hr>
<pre>  def sec() time[2] end</pre><br/>
Get the second of this date. <hr>
<pre>  def sec_fraction() time[3] end</pre><br/>
Get the fraction-of-a-second of this date. <hr>
<pre>  def cwyear() commercial[0] end</pre><br/>
Get the commercial year of this date.  See <b>Commercial</b> <b>Date</b> in the introduction for how this differs from the normal year. <hr>
<pre>  def cweek() commercial[1] end</pre><br/>
Get the commercial week of the year of this date. <hr>
<pre>  def cwday() commercial[2] end</pre><br/>
Get the commercial day of the week of this date.  Monday is commercial day-of-week 1; Sunday is commercial day-of-week 7. <hr>
<pre>  def wday() self.class.jd_to_wday(jd) end</pre><br/>
Get the week day of this date.  Sunday is day-of-week 0; Saturday is day-of-week 6. <hr>
<pre>  def os? () self.class.os?(jd, @sg) end</pre><br/>
Is the current date old-style (Julian Calendar)? <hr>
<pre>  def ns? () self.class.ns?(jd, @sg) end</pre><br/>
Is the current date new-style (Gregorian Calendar)? <hr>
<pre>  def leap?</pre><br/>
Is this a leap year? <hr>
<pre>  def start() @sg end</pre><br/>
When is the Day of Calendar Reform for this Date object? <hr>
<pre>  def new_start(sg=self.class::ITALY) self.class.new0(@ajd, @of, sg) end</pre><br/>
Create a copy of this Date object using a new Day of Calendar Reform. <hr>
<pre>  def italy() new_start(self.class::ITALY) end</pre><br/>
Create a copy of this Date object that uses the Italian/Catholic Day of Calendar Reform. <hr>
<pre>  def england() new_start(self.class::ENGLAND) end</pre><br/>
Create a copy of this Date object that uses the English/Colonial Day of Calendar Reform. <hr>
<pre>  def julian() new_start(self.class::JULIAN) end</pre><br/>
Create a copy of this Date object that always uses the Julian Calendar. <hr>
<pre>  def gregorian() new_start(self.class::GREGORIAN) end</pre><br/>
Create a copy of this Date object that always uses the Gregorian Calendar. <hr>
<pre>  def + (n)</pre><br/>
Return a new Date object that is <tt>n</tt> days later than the current one. <br><br><tt>n</tt> may be a negative value, in which case the new Date is earlier than the current one; however, #-() might be more intuitive. <br><br>If <tt>n</tt> is not a Numeric, a TypeError will be thrown.  In particular, two Dates cannot be added to each other. <hr>
<pre>  def - (x)</pre><br/>
If <tt>x</tt> is a Numeric value, create a new Date object that is <tt>x</tt> days earlier than the current one. <br><br>If <tt>x</tt> is a Date, return the number of days between the two dates; or, more precisely, how many days later the current date is than <tt>x</tt>. <br><br>If <tt>x</tt> is neither Numeric nor a Date, a TypeError is raised. <hr>
<pre>  def <=> (other)</pre><br/>
Compare this date with another date. <br><br><tt>other</tt> can also be a Numeric value, in which case it is interpreted as an Astronomical Julian Day Number. <br><br>Comparison is by Astronomical Julian Day Number, including fractional days.  This means that both the time and the timezone offset are taken into account when comparing two DateTime instances.  When comparing a DateTime instance with a Date instance, the time of the latter will be considered as falling on midnight UTC. <hr>
<pre>  def === (other)</pre><br/>
The relationship operator for Date. <br><br>Compares dates by Julian Day Number.  When comparing two DateTime instances, or a DateTime with a Date, the instances will be regarded as equivalent if they fall on the same date in local time. <hr>
<pre>  def >> (n)</pre><br/>
Return a new Date object that is <tt>n</tt> months later than the current one. <br><br>If the day-of-the-month of the current Date is greater than the last day of the target month, the day-of-the-month of the returned Date will be the last day of the target month. <hr>
<pre>  def << (n) self >> -n end</pre><br/>
Return a new Date object that is <tt>n</tt> months earlier than the current one. <br><br>If the day-of-the-month of the current Date is greater than the last day of the target month, the day-of-the-month of the returned Date will be the last day of the target month. <hr>
<pre>  def step(limit, step)  # :yield: date</pre><br/>
Step the current date forward <tt>step</tt> days at a time (or backward, if <tt>step</tt> is negative) until we reach <tt>limit</tt> (inclusive), yielding the resultant date at each step. <hr>
<pre>  def upto(max, &block)  # :yield: date</pre><br/>
Step forward one day at a time until we reach <tt>max</tt> (inclusive), yielding each date as we go. <hr>
<pre>  def downto(min, &block) # :yield: date</pre><br/>
Step backward one day at a time until we reach <tt>min</tt> (inclusive), yielding each date as we go. <hr>
<pre>  def succ() self + 1 end</pre><br/>
Return a new Date one day after this one. <hr>
<pre>  def eql? (other) Date === other and self == other end</pre><br/>
Is this Date equal to <tt>other</tt>? <br><br><tt>other</tt> must both be a Date object, and represent the same date. <hr>
<pre>  def hash() @ajd.hash end</pre><br/>
Calculate a hash value for this date. <hr>
<pre>  def inspect() format('#<%s: %s,%s,%s>', self.class, @ajd, @of, @sg) end</pre><br/>
Return internal object state as a programmer-readable string. <hr>
<pre>  def to_s() strftime end</pre><br/>
Return the date as a human-readable string. <br><br>The format used is YYYY-MM-DD. <hr>
<pre>  def _dump(limit) Marshal.dump([@ajd, @of, @sg], -1) end</pre><br/>
Dump to Marshal format. <hr>
<br/>
def self._load(str) new0(*Marshal.load(str)) end <hr>
<pre>  def self._load(str)</pre><br/>
Load from Marshall format. <hr>
<pre>class DateTime < Date</pre><br/>
Class representing a date and time. <br><br>See the documentation to the file date.rb for an overview. <br><br>DateTime objects are immutable once created. <br><h2> Other methods.</h2>
The following methods are defined in Date, but declared private there.  They are made public in DateTime.  They are documented here. <br><h3> hour()</h3>
Get the hour-of-the-day of the time.  This is given using the 24-hour clock, counting from midnight.  The first hour after midnight is hour 0; the last hour of the day is hour 23. <br><h3> min()</h3>
Get the minute-of-the-hour of the time. <br><h3> sec()</h3>
Get the second-of-the-minute of the time. <br><h3> sec_fraction()</h3>
Get the fraction of a second of the time.  This is returned as a <tt>Rational</tt>. <br><h3> zone()</h3>
Get the time zone as a String.  This is representation of the time offset such as "+1000", not the true time-zone name. <br><h3> offset()</h3>
Get the time zone offset as a fraction of a day.  This is returned as a <tt>Rational</tt>. <br><h3> new_offset(of=0)</h3>
Create a new DateTime object, identical to the current one, except with a new time zone offset of <tt>of</tt>.  <tt>of</tt> is the new offset from UTC as a fraction of a day. <br><br><hr>
<pre>  def self.valid_time? (h, min, s)</pre><br/>
Do hour <tt>h</tt>, minute <tt>min</tt>, and second <tt>s</tt> constitute a valid time? <br><br>If they do, returns their value as a fraction of a day.  If not, returns nil. <br><br>The 24-hour clock is used.  Negative values of <tt>h</tt>, <tt>min</tt>, and <tt>sec</tt> are treating as counting backwards from the end of the next larger unit (e.g. a <tt>min</tt> of -2 is treated as 58).  No wraparound is performed. <hr>
<pre>  def self.jd(jd=0, h=0, min=0, s=0, of=0, sg=ITALY)</pre><br/>
Create a new DateTime object corresponding to the specified Julian Day Number <tt>jd</tt> and hour <tt>h</tt>, minute <tt>min</tt>, second <tt>s</tt>. <br><br>The 24-hour clock is used.  Negative values of <tt>h</tt>, <tt>min</tt>, and <tt>sec</tt> are treating as counting backwards from the end of the next larger unit (e.g. a <tt>min</tt> of -2 is treated as 58).  No wraparound is performed.  If an invalid time portion is specified, an ArgumentError is raised. <br><br><tt>of</tt> is the offset from UTC as a fraction of a day (defaults to 0). <tt>sg</tt> specifies the Day of Calendar Reform. <br><br>All day/time values default to 0. <hr>
<pre>  def self.ordinal(y=-4712, d=1, h=0, min=0, s=0, of=0, sg=ITALY)</pre><br/>
Create a new DateTime object corresponding to the specified Ordinal Date and hour <tt>h</tt>, minute <tt>min</tt>, second <tt>s</tt>. <br><br>The 24-hour clock is used.  Negative values of <tt>h</tt>, <tt>min</tt>, and <tt>sec</tt> are treating as counting backwards from the end of the next larger unit (e.g. a <tt>min</tt> of -2 is treated as 58).  No wraparound is performed.  If an invalid time portion is specified, an ArgumentError is raised. <br><br><tt>of</tt> is the offset from UTC as a fraction of a day (defaults to 0). <tt>sg</tt> specifies the Day of Calendar Reform. <br><br><tt>y</tt> defaults to -4712, and <tt>d</tt> to 1; this is Julian Day Number day 0.  The time values default to 0. <hr>
<pre>  def self.civil(y=-4712, m=1, d=1, h=0, min=0, s=0, of=0, sg=ITALY)</pre><br/>
Create a new DateTime object corresponding to the specified Civil Date and hour <tt>h</tt>, minute <tt>min</tt>, second <tt>s</tt>. <br><br>The 24-hour clock is used.  Negative values of <tt>h</tt>, <tt>min</tt>, and <tt>sec</tt> are treating as counting backwards from the end of the next larger unit (e.g. a <tt>min</tt> of -2 is treated as 58).  No wraparound is performed.  If an invalid time portion is specified, an ArgumentError is raised. <br><br><tt>of</tt> is the offset from UTC as a fraction of a day (defaults to 0). <tt>sg</tt> specifies the Day of Calendar Reform. <br><br><tt>y</tt> defaults to -4712, <tt>m</tt> to 1, and <tt>d</tt> to 1; this is Julian Day Number day 0.  The time values default to 0. <hr>
<pre>  def self.commercial(y=1582, w=41, d=5, h=0, min=0, s=0, of=0, sg=ITALY)</pre><br/>
Create a new DateTime object corresponding to the specified Commercial Date and hour <tt>h</tt>, minute <tt>min</tt>, second <tt>s</tt>. <br><br>The 24-hour clock is used.  Negative values of <tt>h</tt>, <tt>min</tt>, and <tt>sec</tt> are treating as counting backwards from the end of the next larger unit (e.g. a <tt>min</tt> of -2 is treated as 58).  No wraparound is performed.  If an invalid time portion is specified, an ArgumentError is raised. <br><br><tt>of</tt> is the offset from UTC as a fraction of a day (defaults to 0). <tt>sg</tt> specifies the Day of Calendar Reform. <br><br><tt>y</tt> defaults to 1582, <tt>w</tt> to 41, and <tt>d</tt> to 5; this is the Day of Calendar Reform for Italy and the Catholic countries. The time values default to 0. <hr>
<pre>  def self.strptime(str='-4712-01-01T00:00:00Z', fmt='%FT%T%Z', sg=ITALY)</pre><br/>
Create a new DateTime object by parsing from a String according to a specified format. <br><br><tt>str</tt> is a String holding a date-time representation. <tt>fmt</tt> is the format that the date-time is in.  See date/format.rb for details on supported formats. <br><br>The default <tt>str</tt> is '-4712-01-01T00:00:00Z', and the default <tt>fmt</tt> is '%FT%T%Z'.  This gives midnight on Julian Day Number day 0. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <br><br>An ArgumentError will be raised if <tt>str</tt> cannot be parsed. <hr>
<pre>  def self.parse(str='-4712-01-01T00:00:00Z', comp=false, sg=ITALY)</pre><br/>
Create a new DateTime object by parsing from a String, without specifying the format. <br><br><tt>str</tt> is a String holding a date-time representation.  <tt>comp</tt> specifies whether to interpret 2-digit years as 19XX (>= 69) or 20XX (&lt; 69); the default is not to. The method will attempt to parse a date-time from the String using various heuristics; see <a href="#_parse">_parse</a> in date/format.rb for more details.  If parsing fails, an ArgumentError will be raised. <br><br>The default <tt>str</tt> is '-4712-01-01T00:00:00Z'; this is Julian Day Number day 0. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. <hr>
<pre>  def self.now(sg=ITALY)</pre><br/>
Create a new DateTime object representing the current time. <br><br><tt>sg</tt> specifies the Day of Calendar Reform. </body></html>
